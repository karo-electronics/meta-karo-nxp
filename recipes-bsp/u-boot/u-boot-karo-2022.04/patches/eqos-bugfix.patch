Index: u-boot-tx93-mb7/drivers/net/dwc_eth_qos.c
===================================================================
--- u-boot-tx93-mb7.orig/drivers/net/dwc_eth_qos.c
+++ u-boot-tx93-mb7/drivers/net/dwc_eth_qos.c
@@ -1189,97 +1189,20 @@ static int eqos_start(struct udevice *de
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret, i;
-	ulong rate;
 	u32 val, tx_fifo_sz, rx_fifo_sz, tqs, rqs, pbl;
 	ulong last_rx_desc;
 	ulong desc_pad;
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
-	eqos->tx_desc_idx = 0;
-	eqos->rx_desc_idx = 0;
-
-	ret = eqos->config->ops->eqos_start_resets(dev);
-	if (ret < 0) {
-		pr_err("eqos_start_resets() failed: %d\n", ret);
+	if (!eqos->phy) {
+		dev_err(dev, "No PHY attached\n");
+		ret = -ENODEV;
 		goto err;
 	}
 
-	udelay(10);
-
-	eqos->reg_access_ok = true;
-
-	if (of_machine_is_compatible("fsl,imx93") &&
-	    eqos->config->interface(dev) == PHY_INTERFACE_MODE_RMII) {
-		u32 intf;
-
-		/* workaround for broken RMII mode on i.MX93 */
-		dev_err(dev, "writel(%08lx, %p)\n", EQOS_DMA_MODE_SWR,
-			&eqos->dma_regs->mode);
-		writel(EQOS_DMA_MODE_SWR, &eqos->dma_regs->mode);
-		dev_err(dev, "writel(%08lx, %p)\n",
-			EQOS_MAC_CONFIGURATION_PS | EQOS_MAC_CONFIGURATION_FES,
-			&eqos->mac_regs->configuration);
-		writel(EQOS_MAC_CONFIGURATION_PS | EQOS_MAC_CONFIGURATION_FES,
-		       &eqos->mac_regs->configuration);
-		intf = readl(&eqos->mac_regs->hw_feature0);
-		dev_err(dev, "HW_FEATURE0=%08x\n", intf);
-		if (((intf >> 28) & 0x7) != 4) {
-			dev_err(dev, "Failed to switch EQOS interface to RMII mode\n");
-			goto err_stop_resets;
-		}
-	}
-
-	ret = wait_for_bit_le32(&eqos->dma_regs->mode,
-				EQOS_DMA_MODE_SWR, false,
-				eqos->config->swr_wait, false);
-	if (ret) {
-		pr_err("EQOS_DMA_MODE_SWR stuck\n");
-		goto err_stop_resets;
-	}
-
-	ret = eqos->config->ops->eqos_calibrate_pads(dev);
-	if (ret < 0) {
-		pr_err("eqos_calibrate_pads() failed: %d\n", ret);
-		goto err_stop_resets;
-	}
-	rate = eqos->config->ops->eqos_get_tick_clk_rate(dev);
-
-	val = (rate / 1000000) - 1;
-	writel(val, &eqos->mac_regs->us_tic_counter);
-
-	/*
-	 * if PHY was already connected and configured,
-	 * don't need to reconnect/reconfigure again
-	 */
-	if (!eqos->phy) {
-		int addr = -1;
-		addr = eqos_get_phy_addr(eqos, dev);
-#ifdef DWC_NET_PHYADDR
-		addr = DWC_NET_PHYADDR;
-#endif
-		eqos->phy = phy_connect(eqos->mii, addr, dev,
-					eqos->config->interface(dev));
-		if (!eqos->phy) {
-			pr_err("phy_connect() failed\n");
-			goto err_stop_resets;
-		}
-
-		if (eqos->max_speed) {
-			ret = phy_set_supported(eqos->phy, eqos->max_speed);
-			if (ret) {
-				pr_err("phy_set_supported() failed: %d\n", ret);
-				goto err_shutdown_phy;
-			}
-		}
-
-		eqos->phy->node = eqos->phy_of_node;
-		ret = phy_config(eqos->phy);
-		if (ret < 0) {
-			pr_err("phy_config() failed: %d\n", ret);
-			goto err_shutdown_phy;
-		}
-	}
+	eqos->tx_desc_idx = 0;
+	eqos->rx_desc_idx = 0;
 
 	ret = phy_startup(eqos->phy);
 	if (ret < 0) {
@@ -1486,10 +1411,9 @@ static int eqos_start(struct udevice *de
 		rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
 		mb();
 		eqos->config->ops->eqos_flush_desc(rx_desc);
-		eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf +
-						(i * EQOS_MAX_PACKET_SIZE),
-						EQOS_MAX_PACKET_SIZE);
 	}
+	eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf,
+					     i * EQOS_MAX_PACKET_SIZE);
 
 	writel(0, &eqos->dma_regs->ch0_txdesc_list_haddress);
 	writel((ulong)eqos_get_desc(eqos, 0, false),
@@ -1528,8 +1452,6 @@ static int eqos_start(struct udevice *de
 
 err_shutdown_phy:
 	phy_shutdown(eqos->phy);
-err_stop_resets:
-	eqos->config->ops->eqos_stop_resets(dev);
 err:
 	pr_err("FAILED: %d\n", ret);
 	return ret;
@@ -1634,59 +1556,28 @@ static int eqos_recv(struct udevice *dev
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	struct eqos_desc *rx_desc;
+	void *dmabuf;
 	int length;
+	static int idle;
 
-	debug("%s(dev=%p, flags=%x):\n", __func__, dev, flags);
+	if (!(flags & ETH_RECV_CHECK_DEVICE))
+		return -EAGAIN;
 
 	rx_desc = eqos_get_desc(eqos, eqos->rx_desc_idx, true);
 	eqos->config->ops->eqos_inval_desc(rx_desc);
 	if (rx_desc->des3 & EQOS_DESC3_OWN) {
-		debug("%s: RX packet not available\n", __func__);
+		if (!idle)
+			debug("%s: No RX packet available rx_desc=%p dma_buf=%p\n",
+			      __func__, rx_desc, eqos->rx_dma_buf);
+		idle = 1;
 		return -EAGAIN;
 	}
+	dev_dbg(dev, "%s(dev=%p, flags=%08x):\n", __func__, dev, flags);
 
-	*packetp = eqos->rx_dma_buf +
-		(eqos->rx_desc_idx * EQOS_MAX_PACKET_SIZE);
+	idle = 0;
+	dmabuf = eqos->rx_dma_buf + eqos->rx_desc_idx * EQOS_MAX_PACKET_SIZE;
 	length = rx_desc->des3 & 0x7fff;
-	debug("%s: *packetp=%p, length=%d\n", __func__, *packetp, length);
-
-	eqos->config->ops->eqos_inval_buffer(*packetp, length);
-
-	return length;
-}
-
-static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
-{
-	struct eqos_priv *eqos = dev_get_priv(dev);
-	uchar *packet_expected;
-	struct eqos_desc *rx_desc;
-
-	debug("%s(packet=%p, length=%d)\n", __func__, packet, length);
-
-	packet_expected = eqos->rx_dma_buf +
-		(eqos->rx_desc_idx * EQOS_MAX_PACKET_SIZE);
-	if (packet != packet_expected) {
-		debug("%s: Unexpected packet (expected %p)\n", __func__,
-		      packet_expected);
-		return -EINVAL;
-	}
-
-	eqos->config->ops->eqos_inval_buffer(packet, length);
-
-	rx_desc = eqos_get_desc(eqos, eqos->rx_desc_idx, true);
 
-	rx_desc->des0 = 0;
-	mb();
-	eqos->config->ops->eqos_flush_desc(rx_desc);
-	eqos->config->ops->eqos_inval_buffer(packet, length);
-	rx_desc->des0 = (u32)(ulong)packet;
-	rx_desc->des1 = 0;
-	rx_desc->des2 = 0;
-	/*
-	 * Make sure that if HW sees the _OWN write below, it will see all the
-	 * writes to the rest of the descriptor too.
-	 */
-	mb();
 	rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
 	eqos->config->ops->eqos_flush_desc(rx_desc);
 
@@ -1695,6 +1586,22 @@ static int eqos_free_pkt(struct udevice
 	eqos->rx_desc_idx++;
 	eqos->rx_desc_idx %= EQOS_DESCRIPTORS_RX;
 
+	*packetp = memalign(ARCH_DMA_MINALIGN, length);
+	if (!*packetp) {
+		dev_err(dev, "Failed to allocate packet buffer\n");
+		return -ENOMEM;
+	}
+
+	eqos->config->ops->eqos_inval_buffer(dmabuf, length);
+	memcpy(*packetp, dmabuf, length);
+
+	return length;
+}
+
+int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
+{
+	debug("%s(packet=%p, length=%d)\n", __func__, packet, length);
+	free(packet);
 	return 0;
 }
 
@@ -1737,7 +1644,7 @@ static int eqos_probe_resources_core(str
 	debug("%s: rx_pkt=%p\n", __func__, eqos->rx_pkt);
 
 	eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf,
-			EQOS_MAX_PACKET_SIZE * EQOS_DESCRIPTORS_RX);
+					     EQOS_MAX_PACKET_SIZE * EQOS_DESCRIPTORS_RX);
 
 	debug("%s: OK\n", __func__);
 	return 0;
@@ -2068,6 +1975,9 @@ static int eqos_probe(struct udevice *de
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
+	ulong rate;
+	u32 val;
+	int addr;
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
@@ -2099,7 +2009,7 @@ static int eqos_probe(struct udevice *de
 	ret = eqos->config->ops->eqos_start_clks(dev);
 	if (ret < 0) {
 		pr_err("eqos_start_clks() failed: %d\n", ret);
-		goto err_remove_resources_tegra;
+		goto err_remove_resources;
 	}
 
 #ifdef CONFIG_DM_ETH_PHY
@@ -2127,15 +2037,93 @@ static int eqos_probe(struct udevice *de
 #ifdef CONFIG_DM_ETH_PHY
 	eth_phy_set_mdio_bus(dev, eqos->mii);
 #endif
+	ret = eqos->config->ops->eqos_start_resets(dev);
+	if (ret < 0) {
+		pr_err("eqos_start_resets() failed: %d\n", ret);
+		goto err_unregister_mdio;
+	}
+
+	udelay(10);
+
+	eqos->reg_access_ok = true;
+
+	if (of_machine_is_compatible("fsl,imx93") &&
+	    eqos->config->interface(dev) == PHY_INTERFACE_MODE_RMII) {
+		u32 intf;
+
+		/* workaround for broken RMII mode on i.MX93 */
+		dev_err(dev, "writel(%08lx, %p)\n", EQOS_DMA_MODE_SWR,
+			&eqos->dma_regs->mode);
+		writel(EQOS_DMA_MODE_SWR, &eqos->dma_regs->mode);
+		dev_err(dev, "writel(%08lx, %p)\n",
+			EQOS_MAC_CONFIGURATION_PS | EQOS_MAC_CONFIGURATION_FES,
+			&eqos->mac_regs->configuration);
+		writel(EQOS_MAC_CONFIGURATION_PS | EQOS_MAC_CONFIGURATION_FES,
+		       &eqos->mac_regs->configuration);
+		intf = readl(&eqos->mac_regs->hw_feature0);
+		dev_err(dev, "HW_FEATURE0=%08x\n", intf);
+		if (((intf >> 28) & 0x7) != 4) {
+			dev_err(dev, "Failed to switch EQOS interface to RMII mode\n");
+			goto err_stop_resets;
+		}
+	}
+
+	ret = wait_for_bit_le32(&eqos->dma_regs->mode,
+				EQOS_DMA_MODE_SWR, false,
+				eqos->config->swr_wait, false);
+	if (ret) {
+		dev_err(dev, "Timeout waiting for soft reset to finish\n");
+		goto err_stop_resets;
+	}
+
+	ret = eqos->config->ops->eqos_calibrate_pads(dev);
+	if (ret < 0) {
+		dev_err(dev, "eqos_calibrate_pads() failed: %d\n", ret);
+		goto err_stop_resets;
+	}
+	rate = eqos->config->ops->eqos_get_tick_clk_rate(dev);
+
+	val = (rate / 1000000) - 1;
+	writel(val, &eqos->mac_regs->us_tic_counter);
+
+	addr = eqos_get_phy_addr(eqos, dev);
+	eqos->phy = phy_connect(eqos->mii, addr, dev,
+				eqos->config->interface(dev));
+	if (!eqos->phy) {
+		dev_err(dev, "phy_connect() failed\n");
+		ret = -EIO;
+		goto err_stop_resets;
+	}
+
+	if (eqos->max_speed) {
+		ret = phy_set_supported(eqos->phy, eqos->max_speed);
+		if (ret) {
+			pr_err("phy_set_supported() failed: %d\n", ret);
+			goto err_shutdown_phy;
+		}
+	}
+
+	eqos->phy->node = eqos->phy_of_node;
+	ret = phy_config(eqos->phy);
+	if (ret < 0) {
+		dev_err(dev, "phy_config() failed: %d\n", ret);
+		goto err_shutdown_phy;
+	}
 
 	debug("%s: OK\n", __func__);
 	return 0;
 
+err_shutdown_phy:
+	phy_shutdown(eqos->phy);
+err_stop_resets:
+	eqos->config->ops->eqos_stop_resets(dev);
+err_unregister_mdio:
+	mdio_unregister(eqos->mii);
 err_free_mdio:
 	mdio_free(eqos->mii);
 err_stop_clks:
 	eqos->config->ops->eqos_stop_clks(dev);
-err_remove_resources_tegra:
+err_remove_resources:
 	eqos->config->ops->eqos_remove_resources(dev);
 err_remove_resources_core:
 	eqos_remove_resources_core(dev);
@@ -2153,6 +2141,7 @@ static int eqos_remove(struct udevice *d
 	mdio_unregister(eqos->mii);
 	mdio_free(eqos->mii);
 	eqos->config->ops->eqos_stop_clks(dev);
+	eqos->config->ops->eqos_stop_resets(dev);
 	eqos->config->ops->eqos_remove_resources(dev);
 
 	eqos_remove_resources_core(dev);
