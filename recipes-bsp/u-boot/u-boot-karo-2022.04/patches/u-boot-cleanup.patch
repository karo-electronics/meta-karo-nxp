diff --git a/Kconfig b/Kconfig
index 0cdc9658f7..a812499c57 100644
--- a/Kconfig
+++ b/Kconfig
@@ -191,6 +191,17 @@ config XEN
 
 	  [1] - https://xenproject.org/
 
+config CHECK_REL_DYN
+	bool "Enable checking of rel.dyn section"
+	depends on ARM
+	help
+	  Enabling this option will perform a consistency check of
+	  the relocation table (.rel.dyn ELF section) to catch possible
+	  corruptions of the relocation table.
+	  Since the .bss section overlays the .rel.dyn section, writing
+	  to variables residing in the .bss section (zero-initialized
+	  static variables) prior to relocation will corrupt the relocation table.
+
 config DISTRO_DEFAULTS
 	bool "Select defaults suitable for booting general purpose Linux distributions"
 	select AUTO_COMPLETE
@@ -492,7 +503,7 @@ config SYS_CUSTOM_LDSCRIPT
 	help
 	  Normally when linking U-Boot we will look in the board directory,
 	  the CPU directory and finally the "cpu" directory of the architecture
-	  for the ile "u-boot.lds" and use that as our linker.  However, in
+	  for the file "u-boot.lds" and use that as our linker.  However, in
 	  some cases we need to provide a different linker script.  To do so,
 	  enable this option and then provide the location under
 	  CONFIG_SYS_LDSCRIPT.
diff --git a/Makefile b/Makefile
index 9a8a7c4681..5e4a6bf2fe 100644
--- a/Makefile
+++ b/Makefile
@@ -1850,7 +1850,9 @@ include/generated/env.txt: $(wildcard $(ENV_FILE)) FORCE
 # Write out the resulting environment, converted to a C string
 quiet_cmd_gen_envt = ENVT    $@
       cmd_gen_envt = \
-	awk -f $(srctree)/scripts/env2string.awk $< >$@
+	awk -f $(srctree)/scripts/env2string.awk $< > $@.tmp; \
+	[ -e $@ ] && cmp -s $@ $@.tmp && rm $@.tmp; \
+	! [ -e $@.tmp ] || mv $@.tmp $@
 $(env_h): include/generated/env.in
 	$(call cmd,gen_envt)
 
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index cac4fa09fd..ca89477446 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -836,7 +836,7 @@ config ARCH_IMX8M
 	select SYS_FSL_HAS_SEC
 	select SYS_FSL_SEC_COMPAT_4
 	select SYS_FSL_SEC_LE
-	select SYS_I2C_MXC
+	imply SYS_I2C_MXC
 	select DM
 	select SUPPORT_SPL
 	imply CMD_DM
diff --git a/arch/arm/include/asm/mach-imx/sys_proto.h b/arch/arm/include/asm/mach-imx/sys_proto.h
index dd0d3f2933..404721fcb7 100644
--- a/arch/arm/include/asm/mach-imx/sys_proto.h
+++ b/arch/arm/include/asm/mach-imx/sys_proto.h
@@ -240,13 +240,6 @@ int mxs_wait_mask_clr(struct mxs_register_32 *reg, u32 mask, u32 timeout);
 
 void board_late_mmc_env_init(void);
 
-unsigned long call_imx_sip(unsigned long id, unsigned long reg0,
-			   unsigned long reg1, unsigned long reg2,
-			   unsigned long reg3);
-unsigned long call_imx_sip_ret2(unsigned long id, unsigned long reg0,
-				unsigned long *reg1, unsigned long reg2,
-				unsigned long reg3);
-
 void imx_get_mac_from_fuse(int dev_id, unsigned char *mac);
 
 #if defined(CONFIG_MX6) || defined(CONFIG_MX7) || defined(CONFIG_MX7ULP)
diff --git a/arch/arm/mach-imx/imx9/Kconfig b/arch/arm/mach-imx/imx9/Kconfig
index c06102bae0..bb6009636c 100644
--- a/arch/arm/mach-imx/imx9/Kconfig
+++ b/arch/arm/mach-imx/imx9/Kconfig
@@ -26,10 +26,15 @@ config TARGET_IMX93_11X11_EVK
 	select IMX93
 	select IMX9_LPDDR4X
 
+config TARGET_TX93
+	bool "Ka-Ro electronics i.MX93 module family"
+	select IMX93
+
 endchoice
 
 source "board/freescale/imx93_evk/Kconfig"
 source "board/freescale/imx93_qsb/Kconfig"
+source "board/karo/imx93/Kconfig"
 
 endif
 
diff --git a/arch/arm/mach-imx/spl.c b/arch/arm/mach-imx/spl.c
index 6b8f4115c4..56304e2ff0 100644
--- a/arch/arm/mach-imx/spl.c
+++ b/arch/arm/mach-imx/spl.c
@@ -275,17 +275,25 @@ u32 spl_mmc_boot_mode(struct mmc *mmc, const u32 boot_device)
  * +------------+ + CSF_PAD_SIZE
  */
 
-__weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
+#include <hexdump.h>
+
+void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
 {
 	typedef void __noreturn (*image_entry_noargs_t)(void);
 	uint32_t offset;
+	const void *fdt_addr = gd->fdt_blob;
 
 	image_entry_noargs_t image_entry =
 		(image_entry_noargs_t)(unsigned long)spl_image->entry_point;
 
 	debug("image entry point: 0x%lX\n", spl_image->entry_point);
-
+debug("fdtaddr=%p flags=%08x\n", fdt_addr, spl_image->flags);
+debug("BL31: %08lx..%08lx\n",
+      spl_image->entry_point, spl_image->entry_point + spl_image->size - 1);
+//fdt_print("/", NULL, 32);
 	if (spl_image->flags & SPL_FIT_FOUND) {
+		asm("\tmov x1, %0\n"
+		    :: "r"(fdt_addr) : "x0", "x1", "x2", "x3");
 		image_entry();
 	} else {
 		/*
@@ -297,6 +305,9 @@ __weak void __noreturn jump_to_image_no_args(struct spl_image_info *spl_image)
 		if (!imx_hab_authenticate_image(spl_image->load_addr,
 						offset + IVT_SIZE +
 						CSF_PAD_SIZE, offset)) {
+
+			asm("\tmov x1, %0\n"
+			    :: "r"(fdt_addr) : "x0", "x1", "x2", "x3");
 			image_entry();
 		} else {
 			panic("spl: ERROR:  image authentication fail\n");
diff --git a/arch/powerpc/lib/interrupts.c b/arch/powerpc/lib/interrupts.c
index bdb8030c27..29fd5af714 100644
--- a/arch/powerpc/lib/interrupts.c
+++ b/arch/powerpc/lib/interrupts.c
@@ -17,6 +17,15 @@
 #include <asm/ptrace.h>
 
 #ifndef CONFIG_MPC83XX_TIMER
+#ifdef CONFIG_SHOW_ACTIVITY
+void board_show_activity (ulong) __attribute__((weak, alias("__board_show_activity")));
+
+void __board_show_activity (ulong dummy)
+{
+	return;
+}
+#endif /* CONFIG_SHOW_ACTIVITY */
+
 #ifndef CONFIG_SYS_WATCHDOG_FREQ
 #define CONFIG_SYS_WATCHDOG_FREQ (CONFIG_SYS_HZ / 2)
 #endif
@@ -87,6 +96,10 @@ void timer_interrupt(struct pt_regs *regs)
 #ifdef CONFIG_LED_STATUS
 	status_led_tick(timestamp);
 #endif /* CONFIG_LED_STATUS */
+
+#ifdef CONFIG_SHOW_ACTIVITY
+	board_show_activity (timestamp);
+#endif /* CONFIG_SHOW_ACTIVITY */
 }
 
 ulong get_timer (ulong base)
diff --git a/boot/image-fdt.c b/boot/image-fdt.c
index b830a0ab41..ecb3faea4a 100644
--- a/boot/image-fdt.c
+++ b/boot/image-fdt.c
@@ -304,28 +304,28 @@ static int select_fdt(struct bootm_headers *images, const char *select, u8 arch,
 	int fdt_noffset;
 
 	if (select) {
-			/*
-			 * If the FDT blob comes from the FIT image and the
-			 * FIT image address is omitted in the command line
-			 * argument, try to use ramdisk or os FIT image
-			 * address or default load address.
-			 */
-			if (images->fit_uname_rd)
-				default_addr = (ulong)images->fit_hdr_rd;
-			else if (images->fit_uname_os)
-				default_addr = (ulong)images->fit_hdr_os;
-			else
-				default_addr = image_load_addr;
-
-			if (fit_parse_conf(select, default_addr, &fdt_addr,
-					   &fit_uname_config)) {
-				debug("*  fdt: config '%s' from image at 0x%08lx\n",
-				      fit_uname_config, fdt_addr);
-			} else if (fit_parse_subimage(select, default_addr, &fdt_addr,
-				   &fit_uname_fdt)) {
-				debug("*  fdt: subimage '%s' from image at 0x%08lx\n",
-				      fit_uname_fdt, fdt_addr);
-			} else
+		/*
+		 * If the FDT blob comes from the FIT image and the
+		 * FIT image address is omitted in the command line
+		 * argument, try to use ramdisk or os FIT image
+		 * address or default load address.
+		 */
+		if (images->fit_uname_rd)
+			default_addr = (ulong)images->fit_hdr_rd;
+		else if (images->fit_uname_os)
+			default_addr = (ulong)images->fit_hdr_os;
+		else
+			default_addr = image_load_addr;
+
+		if (fit_parse_conf(select, default_addr, &fdt_addr,
+				   &fit_uname_config)) {
+			debug("*  fdt: config '%s' from image at 0x%08lx\n",
+			      fit_uname_config, fdt_addr);
+		} else if (fit_parse_subimage(select, default_addr, &fdt_addr,
+					      &fit_uname_fdt)) {
+			debug("*  fdt: subimage '%s' from image at 0x%08lx\n",
+			      fit_uname_fdt, fdt_addr);
+		} else
 #endif
 		{
 			fdt_addr = hextoul(select, NULL);
@@ -440,7 +440,14 @@ static int select_fdt(struct bootm_headers *images, const char *select, u8 arch,
 		break;
 	default:
 		puts("ERROR: Did not find a cmdline Flattened Device Tree\n");
-		return -ENOENT;
+		/*
+		 * allow booting when no explicit fdt address
+		 * was given on the cmdline, but fail otherwise
+		 */
+		if (!select)
+			return -ENOPKG;
+		else
+			return -ENOENT;
 	}
 	*fdt_addrp = fdt_addr;
 
@@ -490,7 +497,11 @@ int boot_get_fdt(int flag, int argc, char *const argv[], uint8_t arch,
 		int ret;
 
 		ret = select_fdt(images, select, arch, &fdt_addr);
-		if (ret == -ENOPKG)
+		if (ret == -ENOPKG && !select)
+			/*
+			 * allow booting when no explicit fdt address
+			 * was given on the cmdline, but fail otherwise
+			 */
 			goto no_fdt;
 		else if (ret)
 			return 1;
@@ -574,8 +585,10 @@ int boot_get_fdt(int flag, int argc, char *const argv[], uint8_t arch,
 	return 0;
 
 no_fdt:
-	debug("Continuing to boot without FDT\n");
-	return 0;
+	if (!select) {
+		debug("Continuing to boot without FDT\n");
+		return 0;
+	}
 error:
 	return 1;
 }
diff --git a/cmd/axi.c b/cmd/axi.c
index b97b43eb7d..5f9139cb05 100644
--- a/cmd/axi.c
+++ b/cmd/axi.c
@@ -134,7 +134,7 @@ static int do_axi_show_bus(struct cmd_tbl *cmdtp, int flag, int argc,
 		show_bus(bus);
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_axi_bus_num(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -162,7 +162,7 @@ static int do_axi_bus_num(struct cmd_tbl *cmdtp, int flag, int argc,
 			printf("Failure changing bus number (%d)\n", ret);
 	}
 
-	return ret ? CMD_RET_FAILURE : 0;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_axi_md(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -261,7 +261,7 @@ static int do_axi_md(struct cmd_tbl *cmdtp, int flag, int argc,
 	dp_last_addr = addr;
 	dp_last_length = length;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_axi_mw(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -313,7 +313,7 @@ static int do_axi_mw(struct cmd_tbl *cmdtp, int flag, int argc,
 		}
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl cmd_axi_sub[] = {
diff --git a/cmd/bdinfo.c b/cmd/bdinfo.c
index bf002f8447..6f89765bce 100644
--- a/cmd/bdinfo.c
+++ b/cmd/bdinfo.c
@@ -138,7 +138,7 @@ int do_bdinfo(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	arch_print_bdinfo();
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/binop.c b/cmd/binop.c
index 592e914690..04f8e20995 100644
--- a/cmd/binop.c
+++ b/cmd/binop.c
@@ -143,7 +143,7 @@ exit:
 	free(src2);
 	free(src1);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/blk_common.c b/cmd/blk_common.c
index 75a072caf5..894ce036f6 100644
--- a/cmd/blk_common.c
+++ b/cmd/blk_common.c
@@ -24,18 +24,18 @@ int blk_common_cmd(int argc, char *const argv[], enum uclass_id uclass_id,
 	case 2:
 		if (strncmp(argv[1], "inf", 3) == 0) {
 			blk_list_devices(if_type);
-			return 0;
+			return CMD_RET_SUCCESS;
 		} else if (strncmp(argv[1], "dev", 3) == 0) {
 			if (blk_print_device_num(if_type, *cur_devnump)) {
 				printf("\nno %s devices available\n", if_name);
 				return CMD_RET_FAILURE;
 			}
-			return 0;
+			return CMD_RET_SUCCESS;
 		} else if (strncmp(argv[1], "part", 4) == 0) {
 			if (blk_list_part(if_type))
 				printf("\nno %s partition table available\n",
 				       if_name);
-			return 0;
+			return CMD_RET_SUCCESS;
 		}
 		return CMD_RET_USAGE;
 	case 3:
@@ -48,7 +48,7 @@ int blk_common_cmd(int argc, char *const argv[], enum uclass_id uclass_id,
 			} else {
 				return CMD_RET_FAILURE;
 			}
-			return 0;
+			return CMD_RET_SUCCESS;
 		} else if (strncmp(argv[1], "part", 4) == 0) {
 			int dev = (int)dectoul(argv[2], NULL);
 
@@ -57,7 +57,7 @@ int blk_common_cmd(int argc, char *const argv[], enum uclass_id uclass_id,
 				       if_name, dev);
 				return CMD_RET_FAILURE;
 			}
-			return 0;
+			return CMD_RET_SUCCESS;
 		}
 		return CMD_RET_USAGE;
 
@@ -76,7 +76,7 @@ int blk_common_cmd(int argc, char *const argv[], enum uclass_id uclass_id,
 
 			printf("%ld blocks read: %s\n", n,
 			       n == cnt ? "OK" : "ERROR");
-			return n == cnt ? 0 : 1;
+			return n == cnt ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 		} else if (strcmp(argv[1], "write") == 0) {
 			ulong addr = hextoul(argv[2], NULL);
 			lbaint_t blk = hextoul(argv[3], NULL);
@@ -91,7 +91,7 @@ int blk_common_cmd(int argc, char *const argv[], enum uclass_id uclass_id,
 
 			printf("%ld blocks written: %s\n", n,
 			       n == cnt ? "OK" : "ERROR");
-			return n == cnt ? 0 : 1;
+			return n == cnt ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 		} else {
 			return CMD_RET_USAGE;
 		}
diff --git a/cmd/blkcache.c b/cmd/blkcache.c
index 47ea1ec0b9..1a4ed07466 100644
--- a/cmd/blkcache.c
+++ b/cmd/blkcache.c
@@ -14,6 +14,7 @@ static int blkc_show(struct cmd_tbl *cmdtp, int flag,
 		     int argc, char *const argv[])
 {
 	struct block_cache_stats stats;
+
 	blkcache_stats(&stats);
 
 	printf("hits: %u\n"
@@ -23,13 +24,14 @@ static int blkc_show(struct cmd_tbl *cmdtp, int flag,
 	       "max cache entries: %u\n",
 	       stats.hits, stats.misses, stats.entries,
 	       stats.max_blocks_per_entry, stats.max_entries);
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int blkc_configure(struct cmd_tbl *cmdtp, int flag,
 			  int argc, char *const argv[])
 {
 	unsigned blocks_per_entry, max_entries;
+
 	if (argc != 3)
 		return CMD_RET_USAGE;
 
@@ -38,7 +40,7 @@ static int blkc_configure(struct cmd_tbl *cmdtp, int flag,
 	blkcache_configure(blocks_per_entry, max_entries);
 	printf("changed to max of %u entries of %u blocks each\n",
 	       max_entries, blocks_per_entry);
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl cmd_blkc_sub[] = {
diff --git a/cmd/bmp.c b/cmd/bmp.c
index 46d0d916e8..0398779ecd 100644
--- a/cmd/bmp.c
+++ b/cmd/bmp.c
@@ -104,7 +104,7 @@ static int do_bmp_info(struct cmd_tbl *cmdtp, int flag, int argc,
 		return CMD_RET_USAGE;
 	}
 
-	return (bmp_info(addr));
+	return bmp_info(addr);
 }
 
 static int do_bmp_display(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -137,7 +137,7 @@ static int do_bmp_display(struct cmd_tbl *cmdtp, int flag, int argc,
 		return CMD_RET_USAGE;
 	}
 
-	 return (bmp_display(addr, x, y));
+	return bmp_display(addr, x, y);
 }
 
 static struct cmd_tbl cmd_bmp_sub[] = {
@@ -206,7 +206,7 @@ static int bmp_info(ulong addr)
 
 	if (bmp == NULL) {
 		printf("There is no valid bmp file at the given address\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	printf("Image size    : %d x %d\n", le32_to_cpu(bmp->header.width),
@@ -217,7 +217,7 @@ static int bmp_info(ulong addr)
 	if (bmp_alloc_addr)
 		free(bmp_alloc_addr);
 
-	return(0);
+	return CMD_RET_SUCCESS;
 }
 
 int bmp_display(ulong addr, int x, int y)
@@ -234,7 +234,7 @@ int bmp_display(ulong addr, int x, int y)
 
 	if (!bmp) {
 		printf("There is no valid bmp file at the given address\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	addr = map_to_sysmem(bmp);
 
@@ -251,5 +251,5 @@ int bmp_display(ulong addr, int x, int y)
 	if (bmp_alloc_addr)
 		free(bmp_alloc_addr);
 
-	return ret ? CMD_RET_FAILURE : 0;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
diff --git a/cmd/boot.c b/cmd/boot.c
index 14839c1ced..637466a3ab 100644
--- a/cmd/boot.c
+++ b/cmd/boot.c
@@ -24,7 +24,6 @@ unsigned long do_go_exec(ulong (*entry)(int, char * const []), int argc,
 static int do_go(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
 	ulong	addr, rc;
-	int     rcode = 0;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
@@ -39,10 +38,9 @@ static int do_go(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	 * and all remaining args
 	 */
 	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
-	if (rc != 0) rcode = 1;
 
 	printf ("## Application terminated, rc = 0x%lX\n", rc);
-	return rcode;
+	return rc ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 /* -------------------------------------------------------------------- */
diff --git a/cmd/booti.c b/cmd/booti.c
index 6ac39193db..979ef85e2f 100644
--- a/cmd/booti.c
+++ b/cmd/booti.c
@@ -62,7 +62,7 @@ static int booti_start(struct cmd_tbl *cmdtp, int flag, int argc,
 		}
 
 		debug("kernel image compression type %d size = 0x%08lx address = 0x%08lx\n",
-			ctype, comp_len, (ulong)dest);
+			ctype, comp_len, dest);
 		decomp_len = comp_len * 10;
 		ret = image_decomp(ctype, 0, ld, IH_TYPE_KERNEL,
 				 (void *)dest, (void *)ld, comp_len,
@@ -108,8 +108,9 @@ int do_booti(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	/* Consume 'booti' */
 	argc--; argv++;
 
-	if (booti_start(cmdtp, flag, argc, argv, &images))
-		return 1;
+	ret = booti_start(cmdtp, flag, argc, argv, &images);
+	if (ret)
+		return ret == -EINVAL ? CMD_RET_USAGE : CMD_RET_FAILURE;
 
 	/*
 	 * We are doing the BOOTM_STATE_LOADOS state ourselves, so must
@@ -131,7 +132,7 @@ int do_booti(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 			      BOOTM_STATE_OS_GO,
 			      &images, 1);
 
-	return ret;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 #ifdef CONFIG_SYS_LONGHELP
diff --git a/cmd/bootm.c b/cmd/bootm.c
index 37c2af96e0..85735fd904 100644
--- a/cmd/bootm.c
+++ b/cmd/bootm.c
@@ -179,7 +179,7 @@ int bootm_maybe_autostart(struct cmd_tbl *cmdtp, const char *cmd)
 		return do_bootm(cmdtp, 0, 1, local_args);
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #ifdef CONFIG_SYS_LONGHELP
@@ -567,12 +567,12 @@ static int do_imls(struct cmd_tbl *cmdtp, int flag, int argc,
 #endif
 
 	if (ret_nor)
-		return ret_nor;
+		return CMD_RET_FAILURE;
 
 	if (ret_nand)
-		return ret_nand;
+		return CMD_RET_FAILURE;
 
-	return (0);
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/bootstage.c b/cmd/bootstage.c
index 77a4bc66ff..fbc50dd129 100644
--- a/cmd/bootstage.c
+++ b/cmd/bootstage.c
@@ -12,7 +12,7 @@ static int do_bootstage_report(struct cmd_tbl *cmdtp, int flag, int argc,
 {
 	bootstage_report();
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int get_base_size(int argc, char *const argv[], ulong *basep,
@@ -46,17 +46,15 @@ static int do_bootstage_stash(struct cmd_tbl *cmdtp, int flag, int argc,
 		return CMD_RET_USAGE;
 	if (base == -1UL) {
 		printf("No bootstage stash area defined\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (0 == strcmp(argv[0], "stash"))
 		ret = bootstage_stash((void *)base, size);
 	else
 		ret = bootstage_unstash((void *)base, size);
-	if (ret)
-		return 1;
 
-	return 0;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl cmd_bootstage_sub[] = {
diff --git a/cmd/btrfs.c b/cmd/btrfs.c
index 98daea99e9..ee4217efbc 100644
--- a/cmd/btrfs.c
+++ b/cmd/btrfs.c
@@ -14,10 +14,10 @@ int do_btrsubvol(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], FS_TYPE_BTRFS))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	btrfs_list_subvols();
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(btrsubvol, 3, 1, do_btrsubvol,
diff --git a/cmd/cbfs.c b/cmd/cbfs.c
index 8a61f2c26f..7899dce339 100644
--- a/cmd/cbfs.c
+++ b/cmd/cbfs.c
@@ -19,20 +19,20 @@ static int do_cbfs_init(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (argc > 2) {
 		printf("usage: cbfsls [end of rom]>\n");
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 	if (argc == 2) {
 		end_of_rom = hextoul(argv[1], &ep);
 		if (*ep) {
 			puts("\n** Invalid end of ROM **\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 	}
 	if (file_cbfs_init(end_of_rom)) {
 		printf("%s.\n", file_cbfs_error());
-		return 1;
+		return CMD_RET_FAILURE;
 	}
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
@@ -54,7 +54,7 @@ static int do_cbfs_fsload(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (argc < 3) {
 		printf("usage: cbfsload <addr> <filename> [bytes]\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	/* parse offset and count */
@@ -70,7 +70,7 @@ static int do_cbfs_fsload(struct cmd_tbl *cmdtp, int flag, int argc,
 			printf("%s: %s\n", file_cbfs_error(), argv[2]);
 		else
 			printf("%s.\n", file_cbfs_error());
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	printf("reading %s\n", file_cbfs_name(file));
@@ -81,7 +81,7 @@ static int do_cbfs_fsload(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	env_set_hex("filesize", size);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
@@ -99,7 +99,7 @@ static int do_cbfs_ls(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (!file) {
 		printf("%s.\n", file_cbfs_error());
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	printf("     size              type  name\n");
@@ -191,7 +191,7 @@ static int do_cbfs_ls(struct cmd_tbl *cmdtp, int flag, int argc,
 	}
 
 	printf("\n%d file(s)\n\n", files);
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
@@ -207,7 +207,7 @@ static int do_cbfs_fsinfo(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (!header) {
 		printf("%s.\n", file_cbfs_error());
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	printf("\n");
@@ -220,7 +220,7 @@ static int do_cbfs_fsinfo(struct cmd_tbl *cmdtp, int flag, int argc,
 	printf("Offset: %#x\n", header->offset);
 	printf("\n");
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/clk.c b/cmd/clk.c
index a483fd8981..81b3fb465d 100644
--- a/cmd/clk.c
+++ b/cmd/clk.c
@@ -29,7 +29,7 @@ static void show_clks(struct udevice *dev, int depth, int last_flag)
 		depth++;
 		rate = clk_get_rate(clkp);
 
-		printf(" %-12u  %8d        ", rate, clkp->enable_count);
+		printf(" %12u  %8d        ", rate, clkp->enable_count);
 
 		for (i = depth; i >= 0; i--) {
 			is_last = (last_flag >> i) & 1;
diff --git a/cmd/console.c b/cmd/console.c
index 9a1db83c7c..5072736154 100644
--- a/cmd/console.c
+++ b/cmd/console.c
@@ -40,7 +40,7 @@ static int do_coninfo(struct cmd_tbl *cmd, int flag, int argc,
 		}
 		putc ('\n');
 	}
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 
diff --git a/cmd/cramfs.c b/cmd/cramfs.c
index 57e2afa247..a7b03d56c1 100644
--- a/cmd/cramfs.c
+++ b/cmd/cramfs.c
@@ -74,11 +74,6 @@ char *mkmodestr(unsigned long mode, char *str)
 }
 #endif /* CONFIG_FS_JFFS2 */
 
-extern int cramfs_check (struct part_info *info);
-extern int cramfs_load (char *loadoffset, struct part_info *info, char *filename);
-extern int cramfs_ls (struct part_info *info, char *filename);
-extern int cramfs_info (struct part_info *info);
-
 /***************************************************/
 /* U-Boot commands				   */
 /***************************************************/
@@ -92,7 +87,7 @@ extern int cramfs_info (struct part_info *info);
  * @param flag command flag
  * @param argc number of arguments supplied to the command
  * @param argv arguments list
- * Return: 0 on success, 1 otherwise
+ * Return: CMD_RET_SUCCESS on success, CMD_RET_FAILURE otherwise
  */
 int do_cramfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 		   char *const argv[])
@@ -106,8 +101,14 @@ int do_cramfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct mtd_device dev;
 	struct mtdids id;
 
+	const char *cramfsaddr = env_get("cramfsaddr");
 	ulong addr;
-	addr = hextoul(env_get("cramfsaddr"), NULL);
+
+	if (!cramfsaddr) {
+		printf("Variable 'cramfsaddr' must be set\n");
+		return CMD_RET_FAILURE;
+	}
+	addr = hextoul(cramfsaddr, NULL);
 
 	/* hack! */
 	/* cramfs_* only supports NOR flash chips */
@@ -149,7 +150,7 @@ int do_cramfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 	unmap_sysmem(offset_virt);
 	unmap_sysmem((void *)(uintptr_t)part.offset);
 
-	return !(size > 0);
+	return size > 0 ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 
 /**
@@ -161,7 +162,7 @@ int do_cramfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
  * @param flag command flag
  * @param argc number of arguments supplied to the command
  * @param argv arguments list
- * Return: 0 on success, 1 otherwise
+ * Return: CMD_RET_SUCCESS on success, CMD_RET_FAILURE otherwise
  */
 int do_cramfs_ls(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
@@ -171,8 +172,14 @@ int do_cramfs_ls(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	struct mtd_device dev;
 	struct mtdids id;
 
+	const char *cramfsaddr = env_get("cramfsaddr");
 	ulong addr;
-	addr = hextoul(env_get("cramfsaddr"), NULL);
+
+	if (!cramfsaddr) {
+		printf("Variable 'cramfsaddr' must be set\n");
+		return CMD_RET_FAILURE;
+	}
+	addr = hextoul(cramfsaddr, NULL);
 
 	/* hack! */
 	/* cramfs_* only supports NOR flash chips */
@@ -192,7 +199,7 @@ int do_cramfs_ls(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		ret = cramfs_ls (&part, filename);
 	unmap_sysmem((void *)(uintptr_t)part.offset);
 
-	return ret ? 0 : 1;
+	return ret ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 
 /* command line only */
diff --git a/cmd/cros_ec.c b/cmd/cros_ec.c
index 90921cecf6..a4ae45ae17 100644
--- a/cmd/cros_ec.c
+++ b/cmd/cros_ec.c
@@ -261,7 +261,7 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 {
 	struct udevice *dev;
 	const char *cmd;
-	int ret = 0;
+	int ret;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
@@ -275,22 +275,22 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 		ret = uclass_get_device(UCLASS_CROS_EC, 0, &dev);
 		if (ret) {
 			printf("Could not init cros_ec device (err %d)\n", ret);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	ret = uclass_get_device(UCLASS_CROS_EC, 0, &dev);
 	if (ret) {
 		printf("Cannot get cros-ec device (err=%d)\n", ret);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	if (0 == strcmp("id", cmd)) {
 		char id[MSG_BYTES];
 
 		if (cros_ec_read_id(dev, id, sizeof(id))) {
 			debug("%s: Could not read KBC ID\n", __func__);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		printf("%s\n", id);
 	} else if (0 == strcmp("info", cmd)) {
@@ -298,7 +298,7 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (cros_ec_info(dev, &info)) {
 			debug("%s: Could not read KBC info\n", __func__);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		printf("rows     = %u\n", info.rows);
 		printf("cols     = %u\n", info.cols);
@@ -317,7 +317,7 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (cros_ec_read_current_image(dev, &image)) {
 			debug("%s: Could not read KBC image\n", __func__);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		printf("%d\n", image);
 	} else if (0 == strcmp("hash", cmd)) {
@@ -326,7 +326,7 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (cros_ec_read_hash(dev, EC_VBOOT_HASH_OFFSET_ACTIVE, &hash)) {
 			debug("%s: Could not read KBC hash\n", __func__);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 
 		if (hash.hash_type == EC_VBOOT_HASH_TYPE_SHA256)
@@ -359,7 +359,7 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (cros_ec_reboot(dev, cmd, 0)) {
 			debug("%s: Could not reboot KBC\n", __func__);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 	} else if (0 == strcmp("events", cmd)) {
 		ret = do_show_events(dev);
@@ -374,7 +374,7 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (cros_ec_clear_host_events(dev, events)) {
 			debug("%s: Could not clear host events\n", __func__);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 	} else if (0 == strcmp("read", cmd)) {
 		ret = do_read_write(dev, 0, argc, argv);
@@ -519,14 +519,13 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (ret) {
 			debug("%s: Could not access LDO%d\n", __func__, index);
-			return ret;
+			return CMD_RET_FAILURE;
 		}
 	} else if (!strcmp("sku", cmd)) {
 		ret = cros_ec_get_sku_id(dev);
 
 		if (ret >= 0) {
 			printf("%d\n", ret);
-			ret = 0;
 		} else {
 			printf("Error: %d\n", ret);
 		}
@@ -536,10 +535,10 @@ static int do_cros_ec(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (ret < 0) {
 		printf("Error: CROS-EC command failed (error %d)\n", ret);
-		ret = 1;
+		return CMD_RET_FAILURE;
 	}
 
-	return ret;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/dataflash_mmc_mux.c b/cmd/dataflash_mmc_mux.c
index 73876e9464..f6e2b118bd 100644
--- a/cmd/dataflash_mmc_mux.c
+++ b/cmd/dataflash_mmc_mux.c
@@ -7,37 +7,37 @@
 #include <common.h>
 #include <command.h>
 
-static int mmc_nspi (const char *);
+static int mmc_nspi(const char *s)
+{
+	if (strcmp(s, "mmc") == 0)
+		return 1;
+	else if (strcmp(s, "spi") == 0)
+		return 0;
+
+	return -1;
+}
 
 int do_dataflash_mmc_mux(struct cmd_tbl *cmdtp, int flag, int argc,
 			 char *const argv[])
 {
 	switch (argc) {
 	case 2:			/* on / off	*/
-		switch (mmc_nspi (argv[1])) {
-		case 0:	AT91F_SelectSPI ();
+		switch (mmc_nspi(argv[1])) {
+		case 0:	AT91F_SelectSPI();
 			break;
-		case 1:	AT91F_SelectMMC ();
+		case 1:	AT91F_SelectMMC();
 			break;
+		default:
+			return CMD_RET_USAGE;
 		}
 	case 1:			/* get status */
-		printf ("Mux is configured to be %s\n",
-			AT91F_GetMuxStatus () ? "MMC" : "SPI");
-		return 0;
+		printf("Mux is configured to be %s\n",
+			AT91F_GetMuxStatus() ? "MMC" : "SPI");
+		return CMD_RET_SUCCESS;
 	default:
 		return CMD_RET_USAGE;
 	}
-	return 0;
-}
-
-static int mmc_nspi (const char *s)
-{
-	if (strcmp (s, "mmc") == 0) {
-		return 1;
-	} else if (strcmp (s, "spi") == 0) {
-		return 0;
-	}
-	return -1;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/disk.c b/cmd/disk.c
index 3d7bc2f601..89cfb7e362 100644
--- a/cmd/disk.c
+++ b/cmd/disk.c
@@ -44,7 +44,7 @@ int common_diskboot(struct cmd_tbl *cmdtp, const char *intf, int argc,
 					&dev_desc, &info, 1);
 	if (part < 0) {
 		bootstage_error(BOOTSTAGE_ID_IDE_TYPE);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	dev = dev_desc->devnum;
@@ -61,7 +61,7 @@ int common_diskboot(struct cmd_tbl *cmdtp, const char *intf, int argc,
 	if (blk_dread(dev_desc, info.start, 1, (ulong *)addr) != 1) {
 		printf("** Read error on %d:%d\n", dev, part);
 		bootstage_error(BOOTSTAGE_ID_IDE_PART_READ);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	bootstage_mark(BOOTSTAGE_ID_IDE_PART_READ);
 
@@ -75,7 +75,7 @@ int common_diskboot(struct cmd_tbl *cmdtp, const char *intf, int argc,
 		if (!image_check_hcrc(hdr)) {
 			puts("\n** Bad Header Checksum **\n");
 			bootstage_error(BOOTSTAGE_ID_IDE_CHECKSUM);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		bootstage_mark(BOOTSTAGE_ID_IDE_CHECKSUM);
 
@@ -95,7 +95,7 @@ int common_diskboot(struct cmd_tbl *cmdtp, const char *intf, int argc,
 	default:
 		bootstage_error(BOOTSTAGE_ID_IDE_FORMAT);
 		puts("** Unknown image type\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	cnt += info.blksz - 1;
@@ -106,7 +106,7 @@ int common_diskboot(struct cmd_tbl *cmdtp, const char *intf, int argc,
 		      (ulong *)(addr + info.blksz)) != cnt) {
 		printf("** Read error on %d:%d\n", dev, part);
 		bootstage_error(BOOTSTAGE_ID_IDE_READ);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	bootstage_mark(BOOTSTAGE_ID_IDE_READ);
 
@@ -117,7 +117,7 @@ int common_diskboot(struct cmd_tbl *cmdtp, const char *intf, int argc,
 		if (fit_check_format(fit_hdr, IMAGE_SIZE_INVAL)) {
 			bootstage_error(BOOTSTAGE_ID_IDE_FIT_READ);
 			puts("** Bad FIT image format\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		bootstage_mark(BOOTSTAGE_ID_IDE_FIT_READ_OK);
 	}
diff --git a/cmd/echo.c b/cmd/echo.c
index fda844ee9d..0ccb829437 100644
--- a/cmd/echo.c
+++ b/cmd/echo.c
@@ -32,7 +32,7 @@ static int do_echo(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (newline)
 		putc('\n');
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/efi.c b/cmd/efi.c
index c0384e0db2..f0a694a03b 100644
--- a/cmd/efi.c
+++ b/cmd/efi.c
@@ -270,7 +270,7 @@ done:
 	if (ret)
 		printf("Error: %d\n", ret);
 
-	return ret ? CMD_RET_FAILURE : 0;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl efi_commands[] = {
diff --git a/cmd/elf.c b/cmd/elf.c
index b7b9f506a5..6cb7c7751f 100644
--- a/cmd/elf.c
+++ b/cmd/elf.c
@@ -41,7 +41,6 @@ int do_bootelf(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	unsigned long addr; /* Address of the ELF image */
 	unsigned long rc; /* Return value from user code */
 	char *sload = NULL;
-	int rcode = 0;
 
 	/* Consume 'bootelf' */
 	argc--; argv++;
@@ -61,7 +60,7 @@ int do_bootelf(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		addr = image_load_addr;
 
 	if (!valid_elf_image(addr))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (sload && sload[1] == 'p')
 		addr = load_elf_image_phdr(addr);
@@ -69,7 +68,7 @@ int do_bootelf(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		addr = load_elf_image_shdr(addr);
 
 	if (!env_get_autostart())
-		return rcode;
+		return CMD_RET_SUCCESS;
 
 	printf("## Starting application at 0x%08lx ...\n", addr);
 	flush();
@@ -79,12 +78,9 @@ int do_bootelf(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	 * and all remaining args
 	 */
 	rc = do_bootelf_exec((void *)addr, argc, argv);
-	if (rc != 0)
-		rcode = 1;
-
 	printf("## Application terminated, rc = 0x%lx\n", rc);
 
-	return rcode;
+	return rc ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 /*
@@ -124,7 +120,7 @@ int do_bootvx(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	 */
 	if ((argc == 2) && (strcmp(argv[1], "tftp") == 0)) {
 		if (net_loop(TFTPGET) <= 0)
-			return 1;
+			return CMD_RET_FAILURE;
 		printf("Automatic boot of VxWorks image at address 0x%08lx ...\n",
 			addr);
 	}
@@ -195,7 +191,7 @@ int do_bootvx(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		bootaddr = base + X86_BOOT_LINE_OFFSET;
 #else
 		printf("## VxWorks bootline address not specified\n");
-		return 1;
+		return CMD_RET_FAILURE;
 #endif
 	}
 
@@ -292,7 +288,7 @@ int do_bootvx(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	puts("## vxWorks terminated\n");
 
-	return 1;
+	return CMD_RET_FAILURE;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/exit.c b/cmd/exit.c
index 2c7132693a..7801927328 100644
--- a/cmd/exit.c
+++ b/cmd/exit.c
@@ -13,7 +13,7 @@ static int do_exit(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (argc > 1)
 		return dectoul(argv[1], NULL);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/fdt.c b/cmd/fdt.c
index 8e51a43126..cd0acc9265 100644
--- a/cmd/fdt.c
+++ b/cmd/fdt.c
@@ -894,6 +894,8 @@ static int is_printable_string(const void *data, int len)
 				return 1;
 			if (s[1] == '\0')
 				return 0;
+		} else if (iscntrl(*s)) {
+			return 0;
 		}
 		s++;
 		len--;
diff --git a/cmd/fpga.c b/cmd/fpga.c
index 8c64e957db..c7a7512364 100644
--- a/cmd/fpga.c
+++ b/cmd/fpga.c
@@ -64,7 +64,7 @@ static int do_fpga_check_params(long *dev, long *fpga_data, size_t *data_size,
 	}
 	*data_size = local_data_size;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #if defined(CONFIG_CMD_FPGA_LOAD_SECURE)
@@ -115,7 +115,8 @@ int do_fpga_loads(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	if (ret)
 		return ret;
 
-	return fpga_loads(dev, (void *)fpga_data, data_size, &fpga_sec_info);
+	ret = fpga_loads(dev, (void *)fpga_data, data_size, &fpga_sec_info);
+	return ret == FPGA_SUCCESS ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 #endif
 
@@ -139,16 +140,19 @@ static int do_fpga_loadfs(struct cmd_tbl *cmdtp, int flag, int argc,
 	fpga_fsinfo.dev_part = argv[5];
 	fpga_fsinfo.filename = argv[6];
 
-	return fpga_fsload(dev, (void *)fpga_data, data_size, &fpga_fsinfo);
+	ret = fpga_fsload(dev, (void *)fpga_data, data_size, &fpga_fsinfo);
+	return ret == FPGA_SUCCESS ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 #endif
 
 static int do_fpga_info(struct cmd_tbl *cmdtp, int flag, int argc,
 			char *const argv[])
 {
+	int ret;
 	long dev = do_fpga_get_device(argv[0]);
 
-	return fpga_info(dev);
+	ret = fpga_info(dev);
+	return ret == FPGA_SUCCESS ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 
 static int do_fpga_dump(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -163,7 +167,8 @@ static int do_fpga_dump(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (ret)
 		return ret;
 
-	return fpga_dump(dev, (void *)fpga_data, data_size);
+	ret = fpga_dump(dev, (void *)fpga_data, data_size);
+	return ret == FPGA_SUCCESS ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 
 static int do_fpga_load(struct cmd_tbl *cmdtp, int flag, int argc,
diff --git a/cmd/help.c b/cmd/help.c
index 8d67d977bf..72f4810889 100644
--- a/cmd/help.c
+++ b/cmd/help.c
@@ -15,7 +15,7 @@ static int do_help(struct cmd_tbl *cmdtp, int flag, int argc,
 	const int len = ll_entry_count(struct cmd_tbl, cmd);
 	return _do_help(start, len, cmdtp, flag, argc, argv);
 #else
-	return 0;
+	return CMD_RET_SUCCESS;
 #endif
 }
 
diff --git a/cmd/io.c b/cmd/io.c
index 2de1111998..4b2c9f84cc 100644
--- a/cmd/io.c
+++ b/cmd/io.c
@@ -49,7 +49,7 @@ int do_io_iod(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		 */
 		size = cmd_get_data_size(argv[0], 4);
 		if (size < 0)
-			return 1;
+			return CMD_RET_FAILURE;
 
 		/* Address is specified since argc > 1 */
 		addr = hextoul(argv[1], NULL);
@@ -88,7 +88,7 @@ int do_io_iod(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	last_length = length;
 	last_size = size;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_io_iow(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
@@ -101,7 +101,7 @@ int do_io_iow(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	size = cmd_get_data_size(argv[0], 4);
 	if (size < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	addr = hextoul(argv[1], NULL);
 	val = hextoul(argv[2], NULL);
@@ -113,7 +113,7 @@ int do_io_iow(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	else
 		outb((u8) val, addr);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 /**************************************************/
diff --git a/cmd/itest.c b/cmd/itest.c
index 74414cbdc4..6775f0de9d 100644
--- a/cmd/itest.c
+++ b/cmd/itest.c
@@ -207,7 +207,7 @@ static int do_itest(struct cmd_tbl *cmdtp, int flag, int argc,
 		break;
 	}
 
-	return !value;
+	return value ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/jffs2.c b/cmd/jffs2.c
index e00fcc2022..d24388b7da 100644
--- a/cmd/jffs2.c
+++ b/cmd/jffs2.c
@@ -132,12 +132,7 @@ struct mtd_device *current_mtd_dev = NULL;
 u8 current_mtd_partnum = 0;
 #endif
 
-#if defined(CONFIG_CMD_CRAMFS)
-extern int cramfs_check (struct part_info *info);
-extern int cramfs_load (char *loadoffset, struct part_info *info, char *filename);
-extern int cramfs_ls (struct part_info *info, char *filename);
-extern int cramfs_info (struct part_info *info);
-#else
+#if !defined(CONFIG_CMD_CRAMFS)
 /* defining empty macros for function names is ugly but avoids ifdef clutter
  * all over the code */
 #define cramfs_check(x)		(0)
@@ -458,7 +453,7 @@ static struct part_info* jffs2_part_info(struct mtd_device *dev, unsigned int pa
  * @param flag command flag
  * @param argc number of arguments supplied to the command
  * @param argv arguments list
- * Return: 0 on success, 1 otherwise
+ * Return: CMD_RET_SUCCESS on success, CMD_RET_FAILURE otherwise
  */
 int do_jffs2_fsload(struct cmd_tbl *cmdtp, int flag, int argc,
 		    char *const argv[])
@@ -485,7 +480,7 @@ int do_jffs2_fsload(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	/* make sure we are in sync with env variables */
 	if (mtdparts_init() !=0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if ((part = jffs2_part_info(current_mtd_dev, current_mtd_partnum))){
 
@@ -504,13 +499,12 @@ int do_jffs2_fsload(struct cmd_tbl *cmdtp, int flag, int argc,
 			printf("### %s load complete: %d bytes loaded to 0x%lx\n",
 				fsname, size, offset);
 			env_set_hex("filesize", size);
+			return CMD_RET_SUCCESS;
 		} else {
 			printf("### %s LOAD ERROR<%x> for %s!\n", fsname, size, filename);
 		}
-
-		return !(size > 0);
 	}
-	return 1;
+	return CMD_RET_FAILURE;
 }
 
 /**
@@ -534,7 +528,7 @@ int do_jffs2_ls(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	/* make sure we are in sync with env variables */
 	if (mtdparts_init() !=0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if ((part = jffs2_part_info(current_mtd_dev, current_mtd_partnum))){
 
@@ -546,9 +540,9 @@ int do_jffs2_ls(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 			ret = jffs2_1pass_ls(part, filename);
 		}
 
-		return ret ? 0 : 1;
+		return ret ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 	}
-	return 1;
+	return CMD_RET_FAILURE;
 }
 
 /**
@@ -570,7 +564,7 @@ int do_jffs2_fsinfo(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	/* make sure we are in sync with env variables */
 	if (mtdparts_init() !=0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if ((part = jffs2_part_info(current_mtd_dev, current_mtd_partnum))){
 
@@ -587,7 +581,7 @@ int do_jffs2_fsinfo(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		return ret ? 0 : 1;
 	}
-	return 1;
+	return CMD_RET_FAILURE;
 }
 
 /***************************************************/
diff --git a/cmd/load.c b/cmd/load.c
index 5c4f34781d..80461b1a3c 100644
--- a/cmd/load.c
+++ b/cmd/load.c
@@ -55,7 +55,7 @@ static int do_load_serial(struct cmd_tbl *cmdtp, int flag, int argc,
 	ulong addr;
 	int i;
 	char *env_echo;
-	int rcode = 0;
+	int rcode = CMD_RET_SUCCESS;
 #ifdef	CONFIG_SYS_LOADS_BAUD_CHANGE
 	int load_baudrate, current_baudrate;
 
@@ -116,7 +116,7 @@ static int do_load_serial(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (addr == ~0) {
 		printf("## S-Record download aborted\n");
-		rcode = 1;
+		rcode = CMD_RET_FAILURE;
 	} else {
 		printf("## Start Addr      = 0x%08lX\n", addr);
 		image_load_addr = addr;
diff --git a/cmd/log.c b/cmd/log.c
index c377aee85c..1a516d9030 100644
--- a/cmd/log.c
+++ b/cmd/log.c
@@ -335,7 +335,7 @@ static int do_log_format(struct cmd_tbl *cmdtp, int flag, int argc,
 		printf("\n");
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_log_rec(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -372,7 +372,7 @@ static int do_log_rec(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (_log(cat, level, file, line, func, "%s\n", msg))
 		return CMD_RET_FAILURE;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #ifdef CONFIG_SYS_LONGHELP
diff --git a/cmd/lzmadec.c b/cmd/lzmadec.c
index 81924da461..b42a87acea 100644
--- a/cmd/lzmadec.c
+++ b/cmd/lzmadec.c
@@ -40,12 +40,12 @@ static int do_lzmadec(struct cmd_tbl *cmdtp, int flag, int argc,
 				       map_sysmem(src, 0), dst_len);
 
 	if (ret != SZ_OK)
-		return 1;
+		return CMD_RET_FAILURE;
 	printf("Uncompressed size: %ld = %#lX\n", (ulong)src_len,
 	       (ulong)src_len);
 	env_set_hex("filesize", src_len);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/md5sum.c b/cmd/md5sum.c
index 0f0e1d3dd6..29d039a650 100644
--- a/cmd/md5sum.c
+++ b/cmd/md5sum.c
@@ -118,7 +118,7 @@ int do_md5sum(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		if (parse_verify_sum(verify_str, vsum)) {
 			printf("ERROR: %s does not contain a valid md5 sum\n",
 				verify_str);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		if (memcmp(output, vsum, 16) != 0) {
 			printf("md5 for %08lx ... %08lx ==> ", addr,
@@ -129,11 +129,11 @@ int do_md5sum(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 			for (i = 0; i < 16; i++)
 				printf("%02x", vsum[i]);
 			printf(" ** ERROR **\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #else
 static int do_md5sum(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -162,7 +162,7 @@ static int do_md5sum(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (argc > 3)
 		store_result(output, argv[3]);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #endif
 
diff --git a/cmd/mdio.c b/cmd/mdio.c
index 3c74326161..9a9d7a3c8c 100644
--- a/cmd/mdio.c
+++ b/cmd/mdio.c
@@ -279,7 +279,7 @@ static int do_mdio(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (op[0] == 'l') {
 		mdio_list_devices();
 
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	/* Save the chosen bus */
@@ -309,7 +309,7 @@ static int do_mdio(struct cmd_tbl *cmdtp, int flag, int argc,
 	last_reg_hi  = reghi;
 	last_data    = data;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 /***************************************************/
diff --git a/cmd/mii.c b/cmd/mii.c
index fab420ee29..43e4e18886 100644
--- a/cmd/mii.c
+++ b/cmd/mii.c
@@ -284,7 +284,7 @@ static int do_mii(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	unsigned char	addrlo, addrhi, reglo, reghi;
 	unsigned char	addr, reg;
 	unsigned short	data, mask;
-	int		rcode = 0;
+	int		rcode = CMD_RET_SUCCESS;
 	const char	*devname;
 
 	if (argc < 2)
@@ -373,7 +373,7 @@ static int do_mii(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 					printf(
 					"Error reading from the PHY addr=%02x reg=%02x\n",
 						addr, reg);
-					rcode = 1;
+					rcode = CMD_RET_FAILURE;
 				} else {
 					if ((addrlo != addrhi) || (reglo != reghi))
 						printf("addr=%02x reg=%02x data=",
@@ -390,7 +390,7 @@ static int do_mii(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 				if (miiphy_write (devname, addr, reg, data) != 0) {
 					printf("Error writing to the PHY addr=%02x reg=%02x\n",
 						addr, reg);
-					rcode = 1;
+					rcode = CMD_RET_FAILURE;
 				}
 			}
 		}
@@ -403,7 +403,7 @@ static int do_mii(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 					printf("Error reading from the PHY");
 					printf(" addr=%02x", addr);
 					printf(" reg=%02x\n", reg);
-					rcode = 1;
+					rcode = CMD_RET_FAILURE;
 				} else {
 					val = (val & ~mask) | (data & mask);
 					if (miiphy_write(devname, addr,
@@ -411,7 +411,7 @@ static int do_mii(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 						printf("Error writing to the PHY");
 						printf(" addr=%02x", addr);
 						printf(" reg=%02x\n", reg);
-						rcode = 1;
+						rcode = CMD_RET_FAILURE;
 					}
 				}
 			}
@@ -421,7 +421,7 @@ static int do_mii(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		int ok = 1;
 		if (reglo > MII_STAT1000 || reghi > MII_STAT1000) {
 			printf("The MII dump command only formats the standard MII registers, 0-5, 9-a.\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		for (addr = addrlo; addr <= addrhi; addr++) {
 			for (reg = reglo; reg <= reghi; reg++) {
@@ -431,7 +431,7 @@ static int do_mii(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 					printf(
 					"Error reading from the PHY addr=%02x reg=%02x\n",
 						addr, reg);
-					rcode = 1;
+					rcode = CMD_RET_FAILURE;
 				}
 			}
 			if (ok)
diff --git a/cmd/misc.c b/cmd/misc.c
index ec32b41ed1..a4b6fca1db 100644
--- a/cmd/misc.c
+++ b/cmd/misc.c
@@ -38,7 +38,7 @@ static int do_misc_list(struct cmd_tbl *cmdtp, int flag,
 		       dev->driver->name);
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_misc_op(struct cmd_tbl *cmdtp, int flag,
@@ -53,7 +53,7 @@ static int do_misc_op(struct cmd_tbl *cmdtp, int flag,
 	ret = uclass_get_device_by_name(UCLASS_MISC, argv[0], &dev);
 	if (ret) {
 		printf("Unable to find device %s\n", argv[0]);
-		return ret;
+		return CMD_RET_FAILURE;
 	}
 
 	offset = hextoul(argv[1], NULL);
@@ -78,7 +78,7 @@ static int do_misc_op(struct cmd_tbl *cmdtp, int flag,
 			printf("Partially %s %d bytes\n", misc_op_str[op], ret);
 	}
 
-	return ret;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_misc_read(struct cmd_tbl *cmdtp, int flag,
diff --git a/cmd/mmc.c b/cmd/mmc.c
index c79d940798..7dc41c5a36 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -81,12 +81,14 @@ static void print_mmcinfo(struct mmc *mmc)
 			puts(" WRREL\n");
 		else
 			putc('\n');
+#ifndef CONFIG_SPL_BUILD
 		if (usr_enh) {
 			puts("User Enhanced Start: ");
 			print_size(mmc->enh_user_start, "\n");
 			puts("User Enhanced Size: ");
 			print_size(mmc->enh_user_size, "\n");
 		}
+#endif
 		puts("Boot Capacity: ");
 		print_size(mmc->capacity_boot, has_enh ? " ENH\n" : "\n");
 		puts("RPMB Capacity: ");
@@ -175,7 +177,7 @@ static int do_mmcinfo(struct cmd_tbl *cmdtp, int flag, int argc,
 			curr_device = 0;
 		else {
 			puts("No MMC device available\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 	}
 
@@ -584,7 +586,7 @@ static int do_mmc_dev(struct cmd_tbl *cmdtp, int flag,
 	printf("switch to partitions #%d, %s\n",
 	       part, (!ret) ? "OK" : "ERROR");
 	if (ret)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	curr_device = dev;
 	if (mmc->part_config == MMCPART_NOAVAILABLE)
@@ -913,7 +915,7 @@ static int mmc_partconf_print(struct mmc *mmc, const char *varname)
 	ack = EXT_CSD_EXTRACT_BOOT_ACK(mmc->part_config);
 	part = EXT_CSD_EXTRACT_BOOT_PART(mmc->part_config);
 
-	if(varname)
+	if (varname)
 		env_set_hex(varname, part);
 
 	printf("EXT_CSD[179], PARTITION_CONFIG:\n"
@@ -953,12 +955,14 @@ static int do_mmc_partconf(struct cmd_tbl *cmdtp, int flag,
 	access = dectoul(argv[4], NULL);
 
 	/* acknowledge to be sent during boot operation */
-	return mmc_set_part_conf(mmc, ack, part_num, access);
+	return mmc_set_part_conf(mmc, ack, part_num, access) ?
+		CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_mmc_rst_func(struct cmd_tbl *cmdtp, int flag,
 			   int argc, char *const argv[])
 {
+	int ret;
 	int dev;
 	struct mmc *mmc;
 	u8 enable;
@@ -988,7 +992,10 @@ static int do_mmc_rst_func(struct cmd_tbl *cmdtp, int flag,
 		return CMD_RET_FAILURE;
 	}
 
-	return mmc_set_rst_n_function(mmc, enable);
+	ret = mmc_set_rst_n_function(mmc, enable);
+	if (ret == 0)
+		return CMD_RET_SUCCESS;
+	return ret == -EINVAL ? CMD_RET_USAGE : CMD_RET_FAILURE;
 }
 #endif
 static int do_mmc_setdsr(struct cmd_tbl *cmdtp, int flag,
@@ -1016,7 +1023,7 @@ static int do_mmc_setdsr(struct cmd_tbl *cmdtp, int flag,
 		else
 			return CMD_RET_SUCCESS;
 	}
-	return ret;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 #ifdef CONFIG_CMD_BKOPS_ENABLE
@@ -1040,7 +1047,7 @@ static int do_mmc_bkops_enable(struct cmd_tbl *cmdtp, int flag,
 		return CMD_RET_FAILURE;
 	}
 
-	return mmc_set_bkops_enable(mmc);
+	return mmc_set_bkops_enable(mmc) ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 #endif
 
@@ -1129,7 +1136,8 @@ static int do_mmcops(struct cmd_tbl *cmdtp, int flag, int argc,
 			return CMD_RET_FAILURE;
 		}
 	}
-	return cp->cmd(cmdtp, flag, argc, argv);
+	return cp->cmd(cmdtp, flag, argc, argv) ?
+		CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/nand.c b/cmd/nand.c
index 9a723f5757..b31c9314b6 100644
--- a/cmd/nand.c
+++ b/cmd/nand.c
@@ -331,7 +331,7 @@ int do_nand_env_oob(struct cmd_tbl *cmdtp, int argc, char *const argv[])
 		int idx = 0;
 
 		if (argc < 3)
-			goto usage;
+			return CMD_RET_USAGE;
 
 		mtd = get_nand_dev_by_index(idx);
 		/* We don't care about size, or maxsize. */
@@ -391,13 +391,10 @@ int do_nand_env_oob(struct cmd_tbl *cmdtp, int argc, char *const argv[])
 			return 1;
 		}
 	} else {
-		goto usage;
+		return CMD_RET_USAGE;
 	}
 
 	return ret;
-
-usage:
-	return CMD_RET_USAGE;
 }
 
 #endif
@@ -496,7 +493,7 @@ static void adjust_size_for_badblocks(loff_t *size, loff_t offset, int dev)
 static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		   char *const argv[])
 {
-	int i, ret = 0;
+	int i, ret;
 	ulong addr;
 	loff_t off, size, maxsize;
 	char *cmd, *s;
@@ -521,14 +518,14 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	/* Only "dump" is repeatable. */
 	if (repeat && strcmp(cmd, "dump"))
-		return 0;
+		return CMD_RET_SUCCESS;
 
 	if (strcmp(cmd, "info") == 0) {
 
 		putc('\n');
 		for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++)
 			nand_print_and_set_info(i);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	if (strcmp(cmd, "device") == 0) {
@@ -538,13 +535,13 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 				puts("no devices available\n");
 			else
 				nand_print_and_set_info(dev);
-			return 0;
+			return CMD_RET_SUCCESS;
 		}
 
 		dev = (int)dectoul(argv[2], NULL);
 		set_dev(dev);
 
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 #ifdef CONFIG_ENV_OFFSET_OOB
@@ -562,7 +559,7 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 	mtd = get_nand_dev_by_index(dev);
 	if (!mtd) {
 		puts("\nno devices available\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (strcmp(cmd, "bad") == 0) {
@@ -570,7 +567,7 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		for (off = 0; off < mtd->size; off += mtd->erasesize)
 			if (nand_block_isbad(mtd, off))
 				printf("  %08llx\n", (unsigned long long)off);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	/*
@@ -623,10 +620,10 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		if (mtd_arg_off_size(argc - o, argv + o, &dev, &off, &size,
 				     &maxsize, MTD_DEV_TYPE_NAND,
 				     mtd->size) != 0)
-			return 1;
+			return CMD_RET_FAILURE;
 
 		if (set_dev(dev))
-			return 1;
+			return CMD_RET_FAILURE;
 
 		mtd = get_nand_dev_by_index(dev);
 
@@ -646,14 +643,14 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 					opts.scrub = 1;
 				} else {
 					puts("scrub aborted\n");
-					return 1;
+					return CMD_RET_FAILURE;
 				}
 			}
 		}
 		ret = nand_erase_opts(mtd, &opts);
 		printf("%s\n", ret ? "ERROR" : "OK");
 
-		return ret == 0 ? 0 : 1;
+		return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 	}
 
 	if (strncmp(cmd, "dump", 4) == 0) {
@@ -663,7 +660,7 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		off = (int)hextoul(argv[2], NULL);
 		ret = nand_dump(mtd, off, !strcmp(&cmd[4], ".oob"), repeat);
 
-		return ret == 0 ? 1 : 0;
+		return ret ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 	}
 
 	if (strncmp(cmd, "read", 4) == 0 || strncmp(cmd, "write", 5) == 0) {
@@ -692,16 +689,16 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 			if (mtd_arg_off(argv[3], &dev, &off, &size, &maxsize,
 					MTD_DEV_TYPE_NAND,
 					mtd->size))
-				return 1;
+				return CMD_RET_FAILURE;
 
 			if (set_dev(dev))
-				return 1;
+				return CMD_RET_FAILURE;
 
 			mtd = get_nand_dev_by_index(dev);
 
 			if (argc > 4 && !str2long(argv[4], &pagecount)) {
 				printf("'%s' is not a number\n", argv[4]);
-				return 1;
+				return CMD_RET_FAILURE;
 			}
 
 			if (pagecount * mtd->writesize > size) {
@@ -715,10 +712,10 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 					     &size, &maxsize,
 					     MTD_DEV_TYPE_NAND,
 					     mtd->size) != 0)
-				return 1;
+				return CMD_RET_FAILURE;
 
 			if (set_dev(dev))
-				return 1;
+				return CMD_RET_FAILURE;
 
 			/* size is unspecified */
 			if (argc < 5)
@@ -743,7 +740,7 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		} else if (!strcmp(s, ".trimffs")) {
 			if (read) {
 				printf("Unknown nand command suffix '%s'\n", s);
-				return 1;
+				return CMD_RET_FAILURE;
 			}
 			ret = nand_write_skip_bad(mtd, off, &rwsize, NULL,
 						maxsize, (u_char *)addr,
@@ -766,13 +763,13 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 					 no_verify);
 		} else {
 			printf("Unknown nand command suffix '%s'.\n", s);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 
 		printf(" %zu bytes %s: %s\n", rwsize,
 		       read ? "read" : "written", ret ? "ERROR" : "OK");
 
-		return ret == 0 ? 0 : 1;
+		return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 	}
 
 #ifdef CONFIG_CMD_NAND_TORTURE
@@ -785,21 +782,21 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (!str2off(argv[2], &off)) {
 			puts("Offset is not a valid number\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 
 		size = mtd->erasesize;
 		if (argc > 3) {
 			if (!str2off(argv[3], &size)) {
 				puts("Size is not a valid number\n");
-				return 1;
+				return CMD_RET_FAILURE;
 			}
 		}
 
 		endoff = off + size;
 		if (endoff > mtd->size) {
 			puts("Arguments beyond end of NAND\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 
 		off = round_down(off, mtd->erasesize);
@@ -818,7 +815,7 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 			off += mtd->erasesize;
 		}
 		printf(" Passed: %u, failed: %u\n", passed, failed);
-		return failed != 0;
+		return failed ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 	}
 #endif
 
@@ -829,23 +826,24 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		if (argc <= 0)
 			goto usage;
 
+		ret = CMD_RET_SUCCESS;
 		while (argc > 0) {
-			addr = hextoul(*argv, NULL);
+			int rc;
 
-			if (mtd_block_markbad(mtd, addr)) {
-				printf("block 0x%08lx NOT marked "
-					"as bad! ERROR %d\n",
-					addr, ret);
-				ret = 1;
+			addr = hextoul(*argv, NULL);
+			rc = mtd_block_markbad(mtd, addr);
+			if (rc) {
+				printf("block 0x%08lx NOT marked as bad! ERROR %d\n",
+				       addr, rc);
+				ret = CMD_RET_FAILURE;
 			} else {
-				printf("block 0x%08lx successfully "
-					"marked as bad\n",
-					addr);
+				printf("block 0x%08lx successfully marked as bad\n",
+				       addr);
 			}
 			--argc;
 			++argv;
 		}
-		return ret;
+		return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 	}
 
 	if (strcmp(cmd, "biterr") == 0) {
@@ -857,7 +855,7 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		off = (int)simple_strtoul(argv[2], NULL, 16);
 		bit = (int)simple_strtoul(argv[3], NULL, 10);
 		ret = nand_biterror(mtd, off, bit);
-		return ret;
+		return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 	}
 
 #ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
@@ -877,10 +875,10 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 				puts("NAND flash successfully locked\n");
 			} else {
 				puts("Error locking NAND flash\n");
-				return 1;
+				return CMD_RET_FAILURE;
 			}
 		}
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	if (strncmp(cmd, "unlock", 5) == 0) {
@@ -894,10 +892,10 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		if (mtd_arg_off_size(argc - 2, argv + 2, &dev, &off, &size,
 				     &maxsize, MTD_DEV_TYPE_NAND,
 				     mtd->size) < 0)
-			return 1;
+			return CMD_RET_FAILURE;
 
 		if (set_dev(dev))
-			return 1;
+			return CMD_RET_FAILURE;
 
 		mtd = get_nand_dev_by_index(dev);
 
@@ -906,14 +904,11 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		} else {
 			puts("Error unlocking NAND flash, "
 			     "write and erase will probably fail\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 #endif
-
-usage:
-	return CMD_RET_USAGE;
 }
 
 #ifdef CONFIG_SYS_LONGHELP
@@ -988,7 +983,7 @@ static int nand_load_image(struct cmd_tbl *cmdtp, struct mtd_info *mtd,
 	    (strcmp(s, ".jffs2") && strcmp(s, ".e") && strcmp(s, ".i"))) {
 		printf("Unknown nand load suffix '%s'\n", s);
 		bootstage_error(BOOTSTAGE_ID_NAND_SUFFIX);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	printf("\nLoading from %s, offset 0x%lx\n", mtd->name, offset);
@@ -999,7 +994,7 @@ static int nand_load_image(struct cmd_tbl *cmdtp, struct mtd_info *mtd,
 	if (r) {
 		puts("** Read error\n");
 		bootstage_error(BOOTSTAGE_ID_NAND_HDR_READ);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	bootstage_mark(BOOTSTAGE_ID_NAND_HDR_READ);
 
@@ -1025,7 +1020,7 @@ static int nand_load_image(struct cmd_tbl *cmdtp, struct mtd_info *mtd,
 	default:
 		bootstage_error(BOOTSTAGE_ID_NAND_TYPE);
 		puts ("** Unknown image type\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	bootstage_mark(BOOTSTAGE_ID_NAND_TYPE);
 
@@ -1034,7 +1029,7 @@ static int nand_load_image(struct cmd_tbl *cmdtp, struct mtd_info *mtd,
 	if (r) {
 		puts("** Read error\n");
 		bootstage_error(BOOTSTAGE_ID_NAND_READ);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	bootstage_mark(BOOTSTAGE_ID_NAND_READ);
 
@@ -1044,7 +1039,7 @@ static int nand_load_image(struct cmd_tbl *cmdtp, struct mtd_info *mtd,
 		if (fit_check_format(fit_hdr, IMAGE_SIZE_INVAL)) {
 			bootstage_error(BOOTSTAGE_ID_NAND_FIT_READ);
 			puts ("** Bad FIT image format\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		bootstage_mark(BOOTSTAGE_ID_NAND_FIT_READ_OK);
 		fit_print_contents (fit_hdr);
@@ -1076,7 +1071,7 @@ static int do_nandboot(struct cmd_tbl *cmdtp, int flag, int argc,
 		    (find_dev_and_part(p, &dev, &pnum, &part) == 0)) {
 			if (dev->id->type != MTD_DEV_TYPE_NAND) {
 				puts("Not a NAND device\n");
-				return 1;
+				return CMD_RET_FAILURE;
 			}
 			if (argc > 3)
 				goto usage;
@@ -1123,7 +1118,7 @@ usage:
 	if (!boot_device) {
 		puts("\n** No boot device **\n");
 		bootstage_error(BOOTSTAGE_ID_NAND_BOOT_DEVICE);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	bootstage_mark(BOOTSTAGE_ID_NAND_BOOT_DEVICE);
 
@@ -1133,7 +1128,7 @@ usage:
 	if (!mtd) {
 		printf("\n** Device %d not available\n", idx);
 		bootstage_error(BOOTSTAGE_ID_NAND_AVAILABLE);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	bootstage_mark(BOOTSTAGE_ID_NAND_AVAILABLE);
 
diff --git a/cmd/nvedit.c b/cmd/nvedit.c
index 53e6b57b60..01b41b0ebc 100644
--- a/cmd/nvedit.c
+++ b/cmd/nvedit.c
@@ -144,7 +144,7 @@ static int do_env_print(struct cmd_tbl *cmdtp, int flag, int argc,
 		/* print all env vars */
 		rcode = env_print(NULL, env_flag);
 		if (!rcode)
-			return 1;
+			return CMD_RET_FAILURE;
 		printf("\nEnvironment size: %d/%ld bytes\n",
 			rcode, (ulong)ENV_SIZE);
 		return 0;
@@ -213,9 +213,9 @@ DONE:
 	}
 
 	if (len < 2)
-		return 1;
+		return CMD_RET_FAILURE;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #endif
 #endif /* CONFIG_SPL_BUILD */
@@ -257,7 +257,7 @@ static int _do_env_set(int flag, int argc, char *const argv[], int env_flag)
 	if (strchr(name, '=')) {
 		printf("## Error: illegal character '='"
 		       "in variable name \"%s\"\n", name);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	env_id++;
@@ -279,7 +279,7 @@ static int _do_env_set(int flag, int argc, char *const argv[], int env_flag)
 	value = malloc(len);
 	if (value == NULL) {
 		printf("## Can't malloc %d bytes\n", len);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	for (i = 2, s = value; i < argc; ++i) {
 		char *v = argv[i];
@@ -298,10 +298,10 @@ static int _do_env_set(int flag, int argc, char *const argv[], int env_flag)
 	if (!ep) {
 		printf("## Error inserting \"%s\" variable, errno=%d\n",
 			name, errno);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int env_set(const char *varname, const char *varvalue)
@@ -310,7 +310,7 @@ int env_set(const char *varname, const char *varvalue)
 
 	/* before import into hashtable */
 	if (!(gd->flags & GD_FLG_ENV_READY))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (varvalue == NULL || varvalue[0] == '\0')
 		return _do_env_set(0, 2, (char * const *)argv, H_PROGRAMMATIC);
@@ -388,7 +388,7 @@ int do_env_ask(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		size = CONFIG_SYS_CBSIZE - 1;
 
 	if (size <= 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	/* prompt for input */
 	len = cli_readline(message);
@@ -480,7 +480,7 @@ int do_env_callback(struct cmd_tbl *cmdtp, int flag, int argc,
 	printf("\t%-20s %-20s\n", "Variable Name", "Callback Name");
 	printf("\t%-20s %-20s\n", "-------------", "-------------");
 	hwalk_r(&env_htab, print_active_callback);
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #endif
 
@@ -553,7 +553,7 @@ int do_env_flags(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	printf("\t%-20s %-20s %-20s\n", "-------------", "-------------",
 		"---------------");
 	hwalk_r(&env_htab, print_active_flags);
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #endif
 
@@ -572,7 +572,7 @@ static int do_env_edit(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	/* before import into hashtable */
 	if (!(gd->flags & GD_FLG_ENV_READY))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	/* Set read buffer to initial value or empty sting */
 	init_val = env_get(argv[1]);
@@ -582,7 +582,7 @@ static int do_env_edit(struct cmd_tbl *cmdtp, int flag, int argc,
 		buffer[0] = '\0';
 
 	if (cli_readline_into_buffer("edit: ", buffer, 0) < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (buffer[0] == '\0') {
 		const char * const _argv[3] = { "setenv", argv[1], NULL };
@@ -662,7 +662,7 @@ static int do_env_default(struct cmd_tbl *cmdtp, int flag,
 				env_flag |= H_FORCE;
 				break;
 			default:
-				return cmd_usage(cmdtp);
+				return CMD_RET_USAGE;
 			}
 		}
 	}
@@ -671,12 +671,12 @@ static int do_env_default(struct cmd_tbl *cmdtp, int flag,
 		/* Reset the whole environment */
 		env_set_default("## Resetting to default environment\n",
 				env_flag);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 	if (!all && (argc > 0)) {
 		/* Reset individual variables */
 		env_set_default_vars(argc, argv, env_flag);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	return cmd_usage(cmdtp);
@@ -829,12 +829,12 @@ NXTARG:		;
 		if (len < 0) {
 			pr_err("## Error: Cannot export environment: errno = %d\n",
 			       errno);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		sprintf(buf, "%zX", (size_t)len);
 		env_set("filesize", buf);
 
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	envp = (env_t *)ptr;
@@ -850,7 +850,7 @@ NXTARG:		;
 	if (len < 0) {
 		pr_err("## Error: Cannot export environment: errno = %d\n",
 		       errno);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (chk) {
@@ -862,12 +862,12 @@ NXTARG:		;
 	}
 	env_set_hex("filesize", len + offsetof(env_t, data));
 
-	return 0;
+	return CMD_RET_SUCCESS;
 
 sep_err:
 	printf("## Error: %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
 	       cmd);
-	return 1;
+	return CMD_RET_FAILURE;
 }
 #endif
 
@@ -988,7 +988,7 @@ static int do_env_import(struct cmd_tbl *cmdtp, int flag,
 
 		if (size <= offsetof(env_t, data)) {
 			printf("## Error: Invalid size 0x%zX\n", size);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 
 		size -= offsetof(env_t, data);
@@ -996,7 +996,7 @@ static int do_env_import(struct cmd_tbl *cmdtp, int flag,
 
 		if (crc32(0, ep->data, size) != crc) {
 			puts("## Error: bad CRC, import failed\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		ptr = (char *)ep->data;
 	}
@@ -1005,16 +1005,16 @@ static int do_env_import(struct cmd_tbl *cmdtp, int flag,
 		       crlf_is_lf, wl ? argc - 2 : 0, wl ? &argv[2] : NULL)) {
 		pr_err("## Error: Environment import failed: errno = %d\n",
 		       errno);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	gd->flags |= GD_FLG_ENV_READY;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 
 sep_err:
 	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
 		cmd);
-	return 1;
+	return CMD_RET_FAILURE;
 }
 #endif
 
diff --git a/cmd/nvedit_efi.c b/cmd/nvedit_efi.c
index 24944ab81e..fd71417632 100644
--- a/cmd/nvedit_efi.c
+++ b/cmd/nvedit_efi.c
@@ -136,7 +136,7 @@ out:
  *
  * Show information encoded in all the UEFI variables
  */
-static int efi_dump_var_all(int argc,  char *const argv[],
+static int efi_dump_var_all(int argc, char *const argv[],
 			    const efi_guid_t *guid_p, bool verbose)
 {
 	u16 *var_name16, *p;
diff --git a/cmd/nvme.c b/cmd/nvme.c
index 09d5f438fb..b065938530 100644
--- a/cmd/nvme.c
+++ b/cmd/nvme.c
@@ -20,10 +20,7 @@ static int do_nvme(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (argc == 2) {
 		if (strncmp(argv[1], "scan", 4) == 0) {
 			ret = nvme_scan_namespace();
-			if (ret)
-				return CMD_RET_FAILURE;
-
-			return ret;
+			return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 		}
 		if (strncmp(argv[1], "deta", 4) == 0) {
 			struct udevice *udev;
@@ -35,7 +32,7 @@ static int do_nvme(struct cmd_tbl *cmdtp, int flag, int argc,
 
 			nvme_print_info(udev);
 
-			return ret;
+			return CMD_RET_SUCCESS;
 		}
 	}
 
diff --git a/cmd/onenand.c b/cmd/onenand.c
index d633f19d3b..95ab168835 100644
--- a/cmd/onenand.c
+++ b/cmd/onenand.c
@@ -393,17 +393,17 @@ static int do_onenand_read(struct cmd_tbl *cmdtp, int flag, int argc,
 	if ((s != NULL) && (!strcmp(s, ".oob")))
 		oob = 1;
 
-	addr = (ulong)hextoul(argv[1], NULL);
+	addr = hextoul(argv[1], NULL);
 
 	printf("\nOneNAND read: ");
 	if (arg_off_size_onenand(argc - 2, argv + 2, &ofs, &len) != 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
 
-	printf(" %d bytes read: %s\n", retlen, ret ? "ERROR" : "OK");
+	printf(" %zu bytes read: %s\n", retlen, ret ? "ERROR" : "OK");
 
-	return ret == 0 ? 0 : 1;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_onenand_write(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -420,17 +420,17 @@ static int do_onenand_write(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
 		withoob = 1;
 
-	addr = (ulong)hextoul(argv[1], NULL);
+	addr = hextoul(argv[1], NULL);
 
 	printf("\nOneNAND write: ");
 	if (arg_off_size_onenand(argc - 2, argv + 2, &ofs, &len) != 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
 
-	printf(" %d bytes written: %s\n", retlen, ret ? "ERROR" : "OK");
+	printf(" %zu bytes written: %s\n", retlen, ret ? "ERROR" : "OK");
 
-	return ret == 0 ? 0 : 1;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_onenand_erase(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -461,13 +461,13 @@ static int do_onenand_erase(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	/* skip first two or three arguments, look for offset and size */
 	if (arg_off_size_onenand(argc, argv, &ofs, &len) != 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = onenand_block_erase(ofs, len, force);
 
 	printf("%s\n", ret ? "ERROR" : "OK");
 
-	return ret == 0 ? 0 : 1;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_onenand_test(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -487,13 +487,13 @@ static int do_onenand_test(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	/* skip first two or three arguments, look for offset and size */
 	if (arg_off_size_onenand(argc - 1, argv + 1, &ofs, &len) != 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = onenand_block_test(ofs, len);
 
 	printf("%s\n", ret ? "ERROR" : "OK");
 
-	return ret == 0 ? 0 : 1;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_onenand_dump(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -514,7 +514,7 @@ static int do_onenand_dump(struct cmd_tbl *cmdtp, int flag, int argc,
 	else
 		ret = onenand_dump(mtd, ofs, 0);
 
-	return ret == 0 ? 1 : 0;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_onenand_markbad(struct cmd_tbl *cmdtp, int flag, int argc,
diff --git a/cmd/part.c b/cmd/part.c
index 9d419c967c..5dd1044b01 100644
--- a/cmd/part.c
+++ b/cmd/part.c
@@ -41,14 +41,14 @@ static int do_part_uuid(int argc, char *const argv[])
 
 	part = blk_get_device_part_str(argv[0], argv[1], &dev_desc, &info, 0);
 	if (part < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (argc > 2)
 		env_set(argv[2], info.uuid);
 	else
 		printf("%s\n", info.uuid);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_part_list(int argc, char *const argv[])
@@ -85,7 +85,7 @@ static int do_part_list(int argc, char *const argv[])
 
 	ret = blk_get_device_by_str(argv[0], argv[1], &desc);
 	if (ret < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (var != NULL) {
 		int p;
@@ -106,12 +106,12 @@ static int do_part_list(int argc, char *const argv[])
 			strcat(str, t);
 		}
 		env_set(var, str);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	part_print(desc);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_part_info(int argc, char *const argv[], enum cmd_part_info param)
@@ -131,17 +131,17 @@ static int do_part_info(int argc, char *const argv[], enum cmd_part_info param)
 
 	ret = blk_get_device_by_str(argv[0], argv[1], &desc);
 	if (ret < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	part = simple_strtoul(argv[2], &endp, 0);
 	if (*endp == '\0') {
 		err = part_get_info(desc, part, &info);
 		if (err)
-			return 1;
+			return CMD_RET_FAILURE;
 	} else {
 		part = part_get_info_by_name(desc, argv[2], &info);
 		if (part < 0)
-			return 1;
+			return CMD_RET_FAILURE;
 	}
 
 	switch (param) {
@@ -156,7 +156,7 @@ static int do_part_info(int argc, char *const argv[], enum cmd_part_info param)
 		break;
 	default:
 		printf("** Unknown cmd_part_info value: %d\n", param);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (argc > 3)
@@ -164,7 +164,7 @@ static int do_part_info(int argc, char *const argv[], enum cmd_part_info param)
 	else
 		printf("%s\n", buf);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_part_start(int argc, char *const argv[])
diff --git a/cmd/pci.c b/cmd/pci.c
index 58a74755c8..6c100e1111 100644
--- a/cmd/pci.c
+++ b/cmd/pci.c
@@ -499,7 +499,7 @@ static int do_pci(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	int busnum = -1;
 	pci_dev_t bdf = 0;
 	char cmd = 's';
-	int ret = 0;
+	int ret;
 	char *endp;
 
 	if (argc > 1)
@@ -520,13 +520,13 @@ static int do_pci(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	case 'h':		/* header */
 	case 'b':		/* bars */
 		if (argc < 3)
-			goto usage;
+			return CMD_RET_USAGE;
 		if ((bdf = get_pci_dev(argv[2])) == -1)
-			return 1;
+			return CMD_RET_FAILURE;
 		break;
 	case 'e':
 		pci_init();
-		return 0;
+		return CMD_RET_SUCCESS;
 	case 'r': /* no break */
 	default:		/* scan bus */
 		value = 1; /* short listing */
@@ -539,14 +539,14 @@ static int do_pci(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 				if (argv[argc - 1][0] != '*') {
 					busnum = hextoul(argv[argc - 1], &endp);
 					if (*endp)
-						goto usage;
+						return CMD_RET_USAGE;
 				}
 				argc--;
 			}
 			if (cmd == 'r' && argc > 2)
-				goto usage;
+				return CMD_RET_USAGE;
 			else if (cmd != 'r' && (argc > 2 || (argc == 2 && argv[1][0] != 's')))
-				goto usage;
+				return CMD_RET_USAGE;
 		}
 		if (busnum == -1) {
 			if (cmd != 'r') {
@@ -564,7 +564,7 @@ static int do_pci(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 					pci_show_regions(bus);
 				}
 			}
-			return 0;
+			return CMD_RET_SUCCESS;
 		}
 		ret = uclass_get_device_by_seq(UCLASS_PCI, busnum, &bus);
 		if (ret) {
@@ -575,7 +575,7 @@ static int do_pci(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 			pci_show_regions(bus);
 		else
 			pciinfo(bus, value, false);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	ret = dm_pci_bus_find_bdf(bdf, &dev);
@@ -592,29 +592,27 @@ static int do_pci(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		return pci_cfg_display(dev, addr, size, value);
 	case 'n':		/* next */
 		if (argc < 4)
-			goto usage;
+			return CMD_RET_USAGE;
 		ret = pci_cfg_modify(dev, addr, size, value, 0);
 		break;
 	case 'm':		/* modify */
 		if (argc < 4)
-			goto usage;
+			return CMD_RET_USAGE;
 		ret = pci_cfg_modify(dev, addr, size, value, 1);
 		break;
 	case 'w':		/* write */
 		if (argc < 5)
-			goto usage;
+			return CMD_RET_USAGE;
 		ret = dm_pci_write_config(dev, addr, value, size);
 		break;
 	case 'b':		/* bars */
-		return pci_bar_show(dev);
-	default:
-		ret = CMD_RET_USAGE;
+		ret = pci_bar_show(dev);
 		break;
+	default:
+		return CMD_RET_USAGE;
 	}
 
-	return ret;
- usage:
-	return CMD_RET_USAGE;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 /***************************************************/
diff --git a/cmd/pmc.c b/cmd/pmc.c
index 9a3ba2bffc..1daaebf8a2 100644
--- a/cmd/pmc.c
+++ b/cmd/pmc.c
@@ -40,7 +40,7 @@ static int do_pmc_init(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (ret)
 		return CMD_RET_FAILURE;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int do_pmc_info(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -54,7 +54,7 @@ static int do_pmc_info(struct cmd_tbl *cmdtp, int flag, int argc,
 		return CMD_RET_FAILURE;
 	pmc_dump_info(dev);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl cmd_pmc_sub[] = {
diff --git a/cmd/pxe.c b/cmd/pxe.c
index db8e4697f2..6048a0dc61 100644
--- a/cmd/pxe.c
+++ b/cmd/pxe.c
@@ -176,12 +176,12 @@ do_pxe_get(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	pxefile_addr_str = from_env("pxefile_addr_r");
 
 	if (!pxefile_addr_str)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = strict_strtoul(pxefile_addr_str, 16,
 			     (unsigned long *)&pxefile_addr_r);
 	if (ret < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = pxe_get(pxefile_addr_r, &fname, &size);
 	switch (ret) {
@@ -196,7 +196,7 @@ do_pxe_get(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		return CMD_RET_FAILURE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 /*
@@ -215,7 +215,7 @@ do_pxe_boot(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	if (argc == 1) {
 		pxefile_addr_str = from_env("pxefile_addr_r");
 		if (!pxefile_addr_str)
-			return 1;
+			return CMD_RET_FAILURE;
 
 	} else if (argc == 2) {
 		pxefile_addr_str = argv[1];
@@ -225,7 +225,7 @@ do_pxe_boot(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	if (strict_strtoul(pxefile_addr_str, 16, &pxefile_addr_r) < 0) {
 		printf("Invalid pxefile address: %s\n", pxefile_addr_str);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (pxe_setup_ctx(&ctx, cmdtp, do_get_tftp, NULL, false,
@@ -240,7 +240,7 @@ do_pxe_boot(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	copy_filename(net_boot_file_name, "", sizeof(net_boot_file_name));
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl cmd_pxe_sub[] = {
diff --git a/cmd/read.c b/cmd/read.c
index fecfadaa1f..5754859b2a 100644
--- a/cmd/read.c
+++ b/cmd/read.c
@@ -26,16 +26,14 @@ int do_read(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	uint blk;
 	uint cnt;
 
-	if (argc != 6) {
-		cmd_usage(cmdtp);
-		return 1;
-	}
+	if (argc != 6)
+		return CMD_RET_USAGE;
 
 	dev = (int)hextoul(argv[2], &ep);
 	if (*ep) {
 		if (*ep != ':') {
 			printf("Invalid block device %s\n", argv[2]);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		part = (int)hextoul(++ep, NULL);
 	}
@@ -43,7 +41,7 @@ int do_read(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	dev_desc = blk_get_dev(argv[1], dev);
 	if (dev_desc == NULL) {
 		printf("Block device %s %d not supported\n", argv[1], dev);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	addr = map_sysmem(hextoul(argv[3], NULL), 0);
@@ -53,7 +51,7 @@ int do_read(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	if (part != 0) {
 		if (part_get_info(dev_desc, part, &part_info)) {
 			printf("Cannot find partition %d\n", part);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		offset = part_info.start;
 		limit = part_info.size;
@@ -64,15 +62,15 @@ int do_read(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	if (cnt + blk > limit) {
 		printf("Read out of range\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (blk_dread(dev_desc, offset + blk, cnt, addr) != cnt) {
 		printf("Error reading blocks\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/remoteproc.c b/cmd/remoteproc.c
index ca3b436242..b66c76b075 100644
--- a/cmd/remoteproc.c
+++ b/cmd/remoteproc.c
@@ -108,7 +108,7 @@ static int do_remoteproc_list(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (print_remoteproc_list())
 		return CMD_RET_FAILURE;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 /**
@@ -143,7 +143,7 @@ static int do_remoteproc_load(struct cmd_tbl *cmdtp, int flag, int argc,
 	printf("Load Remote Processor %d with data@addr=0x%08lx %lu bytes:%s\n",
 	       id, addr, size, ret ? " Failed!" : " Success!");
 
-	return ret ? CMD_RET_FAILURE : 0;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 /**
@@ -157,7 +157,7 @@ static int do_remoteproc_load(struct cmd_tbl *cmdtp, int flag, int argc,
  * helper routines in remote processor core. by using a set of
  * common checks, we can reduce the amount of code used for this.
  *
- * Return: 0 if no error, else returns appropriate error value.
+ * Return: CMD_RET_SUCCESS if no error, else returns appropriate error value.
  */
 static int do_remoteproc_wrapper(struct cmd_tbl *cmdtp, int flag, int argc,
 				 char *const argv[])
@@ -198,7 +198,7 @@ static int do_remoteproc_wrapper(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (ret < 0)
 		printf("Operation Failed with error (%d)\n", ret);
 
-	return ret ? CMD_RET_FAILURE : 0;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl cmd_remoteproc_sub[] = {
@@ -240,7 +240,7 @@ static struct cmd_tbl cmd_remoteproc_sub[] = {
  *
  * parses up the command table to invoke the correct command.
  *
- * Return: 0 if no error, else returns appropriate error value.
+ * Return: CMD_RET_SUCCESS if no error, else returns appropriate error value.
  */
 static int do_remoteproc(struct cmd_tbl *cmdtp, int flag, int argc,
 			 char *const argv[])
diff --git a/cmd/rng.c b/cmd/rng.c
index 81a23964b8..f31a73a20d 100644
--- a/cmd/rng.c
+++ b/cmd/rng.c
@@ -17,6 +17,6 @@ static int do_rng(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	struct udevice *dev;
 	void *buf;
-	int ret = CMD_RET_SUCCESS;
+	int ret;
 
 	switch (argc) {
 	case 1:
@@ -51,6 +51,7 @@ static int do_rng(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		ret = CMD_RET_FAILURE;
 	} else {
 		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, buf, n);
+		ret = CMD_RET_SUCCESS;
 	}
 
 	return ret;
diff --git a/cmd/sata.c b/cmd/sata.c
index 9c9fe111d1..5f6f9b366a 100644
--- a/cmd/sata.c
+++ b/cmd/sata.c
@@ -44,9 +44,9 @@ int sata_remove(int devnum)
 		return CMD_RET_FAILURE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 #else
-	return sata_stop();
+	return sata_stop() ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 #endif
 }
 
@@ -73,7 +73,7 @@ int sata_probe(int devnum)
 		return CMD_RET_FAILURE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 #else
 	return sata_initialize() < 0 ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 #endif
diff --git a/cmd/sb.c b/cmd/sb.c
index 0d55818e3c..66458f8b9e 100644
--- a/cmd/sb.c
+++ b/cmd/sb.c
@@ -20,7 +20,7 @@ static int do_sb_handoff(struct cmd_tbl *cmdtp, int flag, int argc,
 	else
 		printf("SPL handoff info not received\n");
 
-	return 0;
+	return CMD_RET_SUCCESS;
 #else
 	printf("Command not supported\n");
 
@@ -36,7 +36,7 @@ static int do_sb_state(struct cmd_tbl *cmdtp, int flag, int argc,
 	state = state_get_current();
 	state_show(state);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static struct cmd_tbl cmd_sb_sub[] = {
diff --git a/cmd/setexpr.c b/cmd/setexpr.c
index 4d671e7ef1..78b0c34f46 100644
--- a/cmd/setexpr.c
+++ b/cmd/setexpr.c
@@ -312,7 +312,7 @@ int setexpr_regex_sub(char *data, uint data_size, char *nbuf, uint nbuf_size,
 /*
  * Perform regex operations on a environment variable
  *
- * Returns 0 if OK, 1 in case of errors.
+ * Returns CMD_RET_SUCCESS if OK, CMD_RET_FAILURE in case of errors.
  */
 static int regex_sub_var(const char *name, const char *r, const char *s,
 			 const char *t, int global)
@@ -325,18 +325,18 @@ static int regex_sub_var(const char *name, const char *r, const char *s,
 	int ret;
 
 	if (!name)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (slre_compile(&slre, r) == 0) {
 		printf("Error compiling regex: %s\n", slre.err_str);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (!t) {
 		value = env_get(name);
 		if (!value) {
 			printf("## Error: variable \"%s\" not defined\n", name);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		t = value;
 	}
@@ -349,7 +349,7 @@ static int regex_sub_var(const char *name, const char *r, const char *s,
 	if (len + 1 > SLRE_BUFSZ) {
 		printf("## error: subst buffer overflow: have %d, need %d\n",
 		       SLRE_BUFSZ, len + 1);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	strcpy(data, t);
@@ -357,7 +357,7 @@ static int regex_sub_var(const char *name, const char *r, const char *s,
 	ret = setexpr_regex_sub(data, SLRE_BUFSZ, nbuf, SLRE_PATSZ, r, s,
 				global);
 	if (ret)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	printf("%s=%s\n", name, data);
 
@@ -370,7 +370,7 @@ static int do_setexpr(struct cmd_tbl *cmdtp, int flag, int argc,
 {
 	struct expr_arg aval, bval;
 	ulong value;
-	int ret = 0;
+	int ret;
 	int w;
 
 	/*
@@ -463,14 +463,14 @@ static int do_setexpr(struct cmd_tbl *cmdtp, int flag, int argc,
 				strcpy(str, aval.sval);
 				strcat(str, bval.sval);
 				ret = env_set(argv[1], str);
-				if (ret)
+				if (ret != CMD_RET_SUCCESS)
 					printf("Could not set var\n");
 				free(str);
 			}
 			break;
 		default:
 			printf("invalid op\n");
-			ret = 1;
+			ret = CMD_RET_FAILURE;
 		}
 	} else {
 		ulong a = aval.ival;
@@ -503,10 +503,10 @@ static int do_setexpr(struct cmd_tbl *cmdtp, int flag, int argc,
 			break;
 		default:
 			printf("invalid op\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 
-		env_set_hex(argv[1], value);
+		ret = env_set_hex(argv[1], value);
 	}
 
 	if (w == CMD_DATA_SIZE_STR) {
diff --git a/cmd/sf.c b/cmd/sf.c
index cf92ac4109..5d5156f4e0 100644
--- a/cmd/sf.c
+++ b/cmd/sf.c
@@ -593,7 +593,7 @@ static int do_spi_flash(struct cmd_tbl *cmdtp, int flag, int argc,
 	/* The remaining commands require a selected device */
 	if (!flash) {
 		puts("No SPI flash selected. Please run `sf probe'\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (strcmp(cmd, "read") == 0 || strcmp(cmd, "write") == 0 ||
@@ -610,7 +610,7 @@ static int do_spi_flash(struct cmd_tbl *cmdtp, int flag, int argc,
 
 done:
 	if (ret != -1)
-		return ret;
+		return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 
 usage:
 	return CMD_RET_USAGE;
diff --git a/cmd/smccc.c b/cmd/smccc.c
index 0539a42587..1c98b9d75c 100644
--- a/cmd/smccc.c
+++ b/cmd/smccc.c
@@ -45,7 +45,7 @@ static int do_call(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	printf("Res:  %ld %ld %ld %ld\n", res.a0, res.a1, res.a2, res.a3);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #ifdef CONFIG_CMD_SMC
diff --git a/cmd/sound.c b/cmd/sound.c
index 0b7f959971..301bff5180 100644
--- a/cmd/sound.c
+++ b/cmd/sound.c
@@ -28,7 +28,7 @@ static int do_init(struct cmd_tbl *cmdtp, int flag, int argc,
 		return CMD_RET_FAILURE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 /* play sound from buffer */
@@ -62,4 +62,4 @@ static int do_play(struct cmd_tbl *cmdtp, int flag, int argc,
 		return CMD_RET_FAILURE;
 	}
-	return 0;
+	return CMD_RET_SUCCESS;
 }
diff --git a/cmd/source.c b/cmd/source.c
index 698d9f86d9..052b849bf0 100644
--- a/cmd/source.c
+++ b/cmd/source.c
@@ -185,7 +185,7 @@ static int do_source(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	printf ("## Executing script at %08lx\n", addr);
 	rcode = image_source_script(addr, fit_uname);
-	return rcode;
+	return rcode ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 #ifdef CONFIG_SYS_LONGHELP
diff --git a/cmd/test.c b/cmd/test.c
index fa7c48fb9f..64a4fad7f2 100644
--- a/cmd/test.c
+++ b/cmd/test.c
@@ -59,7 +59,7 @@ static int do_test(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	/* args? */
 	if (argc < 3)
-		return 1;
+		return CMD_RET_USAGE;
 
 #ifdef DEBUG
 	{
@@ -180,7 +180,7 @@ static int do_test(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	debug (": returns %d\n", expr);
 
-	return expr;
+	return expr ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 #undef true
@@ -195,7 +195,7 @@ U_BOOT_CMD(
 static int do_false(struct cmd_tbl *cmdtp, int flag, int argc,
 		    char *const argv[])
 {
-	return 1;
+	return CMD_RET_FAILURE;
 }
 
 U_BOOT_CMD(
@@ -207,7 +207,7 @@ U_BOOT_CMD(
 static int do_true(struct cmd_tbl *cmdtp, int flag, int argc,
 		   char *const argv[])
 {
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/tlv_eeprom.c b/cmd/tlv_eeprom.c
index bf8d453dc5..b4bcd47bf2 100644
--- a/cmd/tlv_eeprom.c
+++ b/cmd/tlv_eeprom.c
@@ -438,7 +438,7 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	if (argc == 1) {
 		read_eeprom(eeprom);
 		show_eeprom(eeprom);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	// We only look at the first character to the command, so "read" and
@@ -450,13 +450,13 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		has_been_read = 0;
 		if (!read_eeprom(eeprom))
 			printf("EEPROM data loaded from device to memory.\n");
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	// Subsequent commands require that the EEPROM has already been read.
 	if (!has_been_read) {
 		printf("Please read the EEPROM data first, using the 'tlv_eeprom read' command.\n");
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	// Handle the commands that don't take parameters
@@ -482,13 +482,13 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 			cmd_usage(cmdtp);
 			break;
 		}
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	// The set command takes one or two args.
 	if (argc > 4) {
 		cmd_usage(cmdtp);
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	// Set command. If the TLV exists in the EEPROM, delete it. Then if
@@ -507,15 +507,15 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		devnum = simple_strtoul(argv[2], NULL, 0);
 		if (devnum > MAX_TLV_DEVICES || !tlv_devices[devnum]) {
 			printf("Invalid device number\n");
-			return 0;
+			return CMD_RET_SUCCESS;
 		}
 		current_dev = devnum;
 		has_been_read = 0;
 	} else {
-		cmd_usage(cmdtp);
+		return CMD_RET_USAGE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 /**
diff --git a/cmd/tpm-common.c b/cmd/tpm-common.c
index d0c63cadf4..b0e79d4bff 100644
--- a/cmd/tpm-common.c
+++ b/cmd/tpm-common.c
@@ -261,16 +261,14 @@ static int tpm_set_device(unsigned long num)
 
 	for_each_tpm_device(dev) {
 		if (n == num) {
-			rc = 0;
+			rc = CMD_RET_SUCCESS;
+			tpm_dev = dev;
 			break;
 		}
 
 		n++;
 	}
 
-	if (!rc)
-		tpm_dev = dev;
-
 	return rc;
 }
 
@@ -293,7 +291,7 @@ int get_tpm(struct udevice **devp)
 	if (devp)
 		*devp = tpm_dev;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_tpm_device(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
@@ -350,7 +348,7 @@ int do_tpm_report_state(struct cmd_tbl *cmdtp, int flag, int argc,
 	}
 	printf("%s\n", buf);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_tpm_init(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
diff --git a/cmd/tpm-v1.c b/cmd/tpm-v1.c
index 0efb079b0a..971847e85e 100644
--- a/cmd/tpm-v1.c
+++ b/cmd/tpm-v1.c
@@ -317,14 +317,15 @@ static int do_tpm_nv_read(struct cmd_tbl *cmdtp, int flag, int argc,
 	void *data;
 	int rc;
 
-	rc = get_tpm(&dev);
-	if (rc)
-		return rc;
-
 	if (argc < 3)
 		return CMD_RET_USAGE;
 	if (argc != 3 + type_string_get_num_values(argv[1]))
 		return CMD_RET_USAGE;
+
+	rc = get_tpm(&dev);
+	if (rc)
+		return rc;
+
 	index = simple_strtoul(argv[2], NULL, 0);
 	data = type_string_alloc(argv[1], &count);
 	if (!data) {
@@ -352,14 +353,15 @@ static int do_tpm_nv_write(struct cmd_tbl *cmdtp, int flag, int argc,
 	void *data;
 	int rc;
 
-	rc = get_tpm(&dev);
-	if (rc)
-		return rc;
-
 	if (argc < 3)
 		return CMD_RET_USAGE;
 	if (argc != 3 + type_string_get_num_values(argv[1]))
 		return CMD_RET_USAGE;
+
+	rc = get_tpm(&dev);
+	if (rc)
+		return rc;
+
 	index = simple_strtoul(argv[2], NULL, 0);
 	data = type_string_alloc(argv[1], &count);
 	if (!data) {
@@ -407,13 +409,13 @@ static int do_tpm_load_key_by_sha1(struct cmd_tbl *cmdtp, int flag, int argc,
 	void *key;
 	struct udevice *dev;
 
+	if (argc < 5)
+		return CMD_RET_USAGE;
+
 	err = get_tpm(&dev);
 	if (err)
 		return err;
 
-	if (argc < 5)
-		return CMD_RET_USAGE;
-
 	parse_byte_string(argv[1], parent_hash, NULL);
 	key = (void *)simple_strtoul(argv[2], NULL, 0);
 	key_len = simple_strtoul(argv[3], NULL, 0);
@@ -449,13 +451,13 @@ static int do_tpm_load_key2_oiap(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int rc;
 
+	if (argc < 5)
+		return CMD_RET_USAGE;
+
 	rc = get_tpm(&dev);
 	if (rc)
 		return rc;
 
-	if (argc < 5)
-		return CMD_RET_USAGE;
-
 	parent_handle = simple_strtoul(argv[1], NULL, 0);
 	key = (void *)simple_strtoul(argv[2], NULL, 0);
 	key_len = simple_strtoul(argv[3], NULL, 0);
@@ -481,13 +483,13 @@ static int do_tpm_get_pub_key_oiap(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int rc;
 
+	if (argc < 3)
+		return CMD_RET_USAGE;
+
 	rc = get_tpm(&dev);
 	if (rc)
 		return rc;
 
-	if (argc < 3)
-		return CMD_RET_USAGE;
-
 	key_handle = simple_strtoul(argv[1], NULL, 0);
 	if (strlen(argv[2]) != 2 * DIGEST_LENGTH)
 		return CMD_RET_FAILURE;
@@ -514,13 +516,13 @@ static int do_tpm_flush(struct cmd_tbl *cmdtp, int flag, int argc,
 	int type = 0;
 	int rc;
 
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
 	rc = get_tpm(&dev);
 	if (rc)
 		return rc;
 
-	if (argc != 3)
-		return CMD_RET_USAGE;
-
 	if (!strcasecmp(argv[1], "key"))
 		type = TPM_RT_KEY;
 	else if (!strcasecmp(argv[1], "auth"))
@@ -544,7 +546,7 @@ static int do_tpm_flush(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (!type) {
 		printf("Resource type %s unknown.\n", argv[1]);
-		return -1;
+		return CMD_RET_USAGE;
 	}
 
 	if (!strcasecmp(argv[2], "all")) {
@@ -559,7 +561,7 @@ static int do_tpm_flush(struct cmd_tbl *cmdtp, int flag, int argc,
 					 sizeof(buf));
 		if (err) {
 			printf("tpm_get_capability returned error %d.\n", err);
-			return -1;
+			return CMD_RET_FAILURE;
 		}
 		res_count = get_unaligned_be16(buf);
 		ptr = buf + 2;
@@ -570,12 +572,12 @@ static int do_tpm_flush(struct cmd_tbl *cmdtp, int flag, int argc,
 
 		if (!handle) {
 			printf("Illegal resource handle %s\n", argv[2]);
-			return -1;
+			return CMD_RET_FAILURE;
 		}
 		tpm1_flush_specific(dev, cpu_to_be32(handle), type);
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #endif /* CONFIG_TPM_FLUSH_RESOURCES */
 
@@ -591,13 +593,13 @@ static int do_tpm_list(struct cmd_tbl *cmdtp, int flag, int argc,
 	int err;
 	uint i;
 
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
 	err = get_tpm(&dev);
 	if (err)
 		return err;
 
-	if (argc != 2)
-		return CMD_RET_USAGE;
-
 	if (!strcasecmp(argv[1], "key"))
 		type = TPM_RT_KEY;
 	else if (!strcasecmp(argv[1], "auth"))
@@ -621,7 +623,7 @@ static int do_tpm_list(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	if (!type) {
 		printf("Resource type %s unknown.\n", argv[1]);
-		return -1;
+		return CMD_RET_USAGE;
 	}
 
 	/* fetch list of already loaded resources in the TPM */
@@ -629,7 +631,7 @@ static int do_tpm_list(struct cmd_tbl *cmdtp, int flag, int argc,
 				 sizeof(buf));
 	if (err) {
 		printf("tpm_get_capability returned error %d.\n", err);
-		return -1;
+		return CMD_RET_FAILURE;
 	}
 	res_count = get_unaligned_be16(buf);
 	ptr = buf + 2;
@@ -642,7 +644,7 @@ static int do_tpm_list(struct cmd_tbl *cmdtp, int flag, int argc,
 			printf("Index %d: %08x\n", i, get_unaligned_be32(ptr));
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #endif /* CONFIG_TPM_LIST_RESOURCES */
 
diff --git a/cmd/tpm-v2.c b/cmd/tpm-v2.c
index d93b83ada9..aaedfb1933 100644
--- a/cmd/tpm-v2.c
+++ b/cmd/tpm-v2.c
@@ -20,11 +20,12 @@ static int do_tpm2_startup(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
 	ret = get_tpm(&dev);
 	if (ret)
 		return ret;
-	if (argc != 2)
-		return CMD_RET_USAGE;
 
 	if (!strcasecmp("TPM2_SU_CLEAR", argv[1])) {
 		mode = TPM2_SU_CLEAR;
@@ -45,11 +46,12 @@ static int do_tpm2_self_test(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
 	ret = get_tpm(&dev);
 	if (ret)
 		return ret;
-	if (argc != 2)
-		return CMD_RET_USAGE;
 
 	if (!strcasecmp("full", argv[1])) {
 		full_test = TPMI_YES;
@@ -72,15 +74,15 @@ static int do_tpm2_clear(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
-	ret = get_tpm(&dev);
-	if (ret)
-		return ret;
-
 	if (argc < 2 || argc > 3)
 		return CMD_RET_USAGE;
 
 	if (pw_sz > TPM2_DIGEST_LEN)
-		return -EINVAL;
+		return CMD_RET_USAGE;
+
+	ret = get_tpm(&dev);
+	if (ret)
+		return ret;
 
 	if (!strcasecmp("TPM2_RH_LOCKOUT", argv[1]))
 		handle = TPM2_RH_LOCKOUT;
@@ -111,10 +113,10 @@ static int do_tpm2_pcr_extend(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	priv = dev_get_uclass_priv(dev);
 	if (!priv)
-		return -EINVAL;
+		return CMD_RET_USAGE;
 
 	if (index >= priv->pcr_count)
-		return -EINVAL;
+		return CMD_RET_USAGE;
 
 	rc = tpm2_pcr_extend(dev, index, TPM2_ALG_SHA256, digest,
 			     TPM2_DIGEST_LEN);
@@ -143,11 +145,11 @@ static int do_tpm_pcr_read(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	priv = dev_get_uclass_priv(dev);
 	if (!priv)
-		return -EINVAL;
+		return CMD_RET_USAGE;
 
 	index = simple_strtoul(argv[1], NULL, 0);
 	if (index >= priv->pcr_count)
-		return -EINVAL;
+		return CMD_RET_USAGE;
 
 	data = map_sysmem(simple_strtoul(argv[2], NULL, 0), 0);
 
@@ -173,13 +175,13 @@ static int do_tpm_get_capability(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
+	if (argc != 5)
+		return CMD_RET_USAGE;
+
 	ret = get_tpm(&dev);
 	if (ret)
 		return ret;
 
-	if (argc != 5)
-		return CMD_RET_USAGE;
-
 	capability = simple_strtoul(argv[1], NULL, 0);
 	property = simple_strtoul(argv[2], NULL, 0);
 	data = map_sysmem(simple_strtoul(argv[3], NULL, 0), 0);
@@ -214,15 +216,15 @@ static int do_tpm_dam_reset(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
+	if (argc > 2)
+		return CMD_RET_USAGE;
+
 	ret = get_tpm(&dev);
 	if (ret)
 		return ret;
 
-	if (argc > 2)
-		return CMD_RET_USAGE;
-
 	if (pw_sz > TPM2_DIGEST_LEN)
-		return -EINVAL;
+		return CMD_RET_USAGE;
 
 	return report_return_code(tpm2_dam_reset(dev, pw, pw_sz));
 }
@@ -242,15 +244,15 @@ static int do_tpm_dam_parameters(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
+	if (argc < 4 || argc > 5)
+		return CMD_RET_USAGE;
+
 	ret = get_tpm(&dev);
 	if (ret)
 		return ret;
 
-	if (argc < 4 || argc > 5)
-		return CMD_RET_USAGE;
-
 	if (pw_sz > TPM2_DIGEST_LEN)
-		return -EINVAL;
+		return CMD_RET_USAGE;
 
 	if (strict_strtoul(argv[1], 0, &max_tries))
 		return CMD_RET_USAGE;
@@ -282,15 +284,15 @@ static int do_tpm_change_auth(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
+	if (argc < 3 || argc > 4)
+		return CMD_RET_USAGE;
+
 	ret = get_tpm(&dev);
 	if (ret)
 		return ret;
 
-	if (argc < 3 || argc > 4)
-		return CMD_RET_USAGE;
-
 	if (newpw_sz > TPM2_DIGEST_LEN || oldpw_sz > TPM2_DIGEST_LEN)
-		return -EINVAL;
+		return CMD_RET_USAGE;
 
 	if (!strcasecmp("TPM2_RH_LOCKOUT", argv[1]))
 		handle = TPM2_RH_LOCKOUT;
@@ -317,16 +319,16 @@ static int do_tpm_pcr_setauthpolicy(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct udevice *dev;
 	int ret;
 
-	ret = get_tpm(&dev);
-	if (ret)
-		return ret;
+	if (argc < 3 || argc > 4)
+		return CMD_RET_USAGE;
 
 	if (strlen(key) != TPM2_DIGEST_LEN)
-		return -EINVAL;
-
-	if (argc < 3 || argc > 4)
 		return CMD_RET_USAGE;
 
+	ret = get_tpm(&dev);
+	if (ret)
+		return ret;
+
 	return report_return_code(tpm2_pcr_setauthpolicy(dev, pw, pw_sz, index,
 							 key));
 }
@@ -342,16 +344,16 @@ static int do_tpm_pcr_setauthvalue(struct cmd_tbl *cmdtp, int flag,
 	struct udevice *dev;
 	int ret;
 
-	ret = get_tpm(&dev);
-	if (ret)
-		return ret;
+	if (argc < 3 || argc > 4)
+		return CMD_RET_USAGE;
 
 	if (strlen(key) != TPM2_DIGEST_LEN)
-		return -EINVAL;
-
-	if (argc < 3 || argc > 4)
 		return CMD_RET_USAGE;
 
+	ret = get_tpm(&dev);
+	if (ret)
+		return ret;
+
 	return report_return_code(tpm2_pcr_setauthvalue(dev, pw, pw_sz, index,
 							key, key_sz));
 }
diff --git a/cmd/tpm_test.c b/cmd/tpm_test.c
index b35eae81dc..32b6c536ab 100644
--- a/cmd/tpm_test.c
+++ b/cmd/tpm_test.c
@@ -41,7 +41,7 @@ static uint32_t TlclStartupIfNeeded(struct udevice *dev)
 static int test_timer(struct udevice *dev)
 {
 	printf("get_timer(0) = %lu\n", get_timer(0));
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static uint32_t tpm_get_flags(struct udevice *dev, uint8_t *disable,
@@ -94,7 +94,7 @@ static int test_early_extend(struct udevice *dev)
 	TPM_CHECK(tpm_pcr_extend(dev, 1, value_in, sizeof(value_in), value_out,
 				 "test"));
 	printf("done\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int test_early_nvram(struct udevice *dev)
@@ -108,7 +108,7 @@ static int test_early_nvram(struct udevice *dev)
 	TPM_CHECK(tpm_tsc_physical_presence(dev, PRESENCE));
 	TPM_CHECK(tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)));
 	printf("done\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int test_early_nvram2(struct udevice *dev)
@@ -122,7 +122,7 @@ static int test_early_nvram2(struct udevice *dev)
 	TPM_CHECK(tpm_tsc_physical_presence(dev, PRESENCE));
 	TPM_CHECK(tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)));
 	printf("done\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int test_enable(struct udevice *dev)
@@ -143,7 +143,7 @@ static int test_enable(struct udevice *dev)
 	if (disable == 1 || deactivated == 1)
 		printf("\tfailed to enable or activate\n");
 	printf("\tdone\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #define reboot() do { \
@@ -177,7 +177,7 @@ static int test_fast_enable(struct udevice *dev)
 		assert(disable == 0 && deactivated == 0);
 	}
 	printf("\tdone\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int test_global_lock(struct udevice *dev)
@@ -218,7 +218,7 @@ static int test_global_lock(struct udevice *dev)
 	TPM_CHECK(tpm_nv_read_value(dev, INDEX1, (uint8_t *)&x, sizeof(x)));
 	assert(x == 2);
 	printf("\tdone\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int test_lock(struct udevice *dev)
@@ -231,7 +231,7 @@ static int test_lock(struct udevice *dev)
 	tpm_nv_write_value_lock(dev, INDEX0);
 	printf("\tLocked 0x%x\n", INDEX0);
 	printf("\tdone\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static void initialise_spaces(struct udevice *dev)
@@ -285,7 +285,7 @@ static int test_readonly(struct udevice *dev)
 				  sizeof(index_3));
 	if (read0 || read1 || read2 || read3) {
 		printf("Invalid contents\n");
-		return 0;
+		return CMD_RET_FAILURE;
 	}
 
 	/*
@@ -305,7 +305,7 @@ static int test_readonly(struct udevice *dev)
 		pr_err("\tindex 0 is not locked\n");
 
 	printf("\tdone\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int test_redefine_unowned(struct udevice *dev)
@@ -357,7 +357,7 @@ static int test_redefine_unowned(struct udevice *dev)
 	assert(result == TPM_BAD_PRESENCE);
 
 	printf("done\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #define PERMPPGL (TPM_NV_PER_PPWRITE | TPM_NV_PER_GLOBALLOCK)
@@ -377,7 +377,7 @@ static int test_space_perm(struct udevice *dev)
 	TPM_CHECK(tpm_get_permissions(dev, INDEX1, &perm));
 	assert((perm & PERMPP) == PERMPP);
 	printf("done\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 static int test_startup(struct udevice *dev)
@@ -399,7 +399,7 @@ static int test_startup(struct udevice *dev)
 	if (result != 0)
 		printf("\ttpm getflags failed with 0x%x\n", result);
 	printf("\tdone\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 /*
@@ -443,7 +443,7 @@ static int test_timing(struct udevice *dev)
 	TTPM_CHECK(tpm_set_global_lock(dev), 50);
 	TTPM_CHECK(tpm_tsc_physical_presence(dev, PHYS_PRESENCE), 100);
 	printf("done\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #define TPM_MAX_NV_WRITES_NOOWNER 64
@@ -485,7 +485,7 @@ static int test_write_limit(struct udevice *dev)
 	/* Try writing again. */
 	TPM_CHECK(tpm_nv_write_value(dev, INDEX0, (uint8_t *)&i, sizeof(i)));
 	printf("\tdone\n");
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 #define VOIDTEST(XFUNC) \
diff --git a/cmd/tsi148.c b/cmd/tsi148.c
index 0d849d9979..e0910574cd 100644
--- a/cmd/tsi148.c
+++ b/cmd/tsi148.c
@@ -442,7 +442,7 @@ int do_tsi148(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		printf("Tsi148: Command %s not supported!\n", argv[1]);
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/ubifs.c b/cmd/ubifs.c
index 6a01d0988a..498556b229 100644
--- a/cmd/ubifs.c
+++ b/cmd/ubifs.c
@@ -50,7 +50,7 @@ static int do_ubifs_mount(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	vol_name = argv[1];
 
-	return cmd_ubifs_mount(vol_name);
+	return cmd_ubifs_mount(vol_name) ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 int ubifs_is_mounted(void)
@@ -78,7 +78,7 @@ static int do_ubifs_umount(struct cmd_tbl *cmdtp, int flag, int argc,
 	if (argc != 1)
 		return CMD_RET_USAGE;
 
-	return cmd_ubifs_umount();
+	return cmd_ubifs_umount() ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_ubifs_ls(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -97,12 +97,10 @@ static int do_ubifs_ls(struct cmd_tbl *cmdtp, int flag, int argc,
 	debug("Using filename %s\n", filename);
 
 	ret = ubifs_ls(filename);
-	if (ret) {
+	if (ret)
 		printf("** File not found %s **\n", filename);
-		ret = CMD_RET_FAILURE;
-	}
 
-	return ret;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 static int do_ubifs_load(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -136,12 +134,10 @@ static int do_ubifs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 	debug("Loading file '%s' to address 0x%08x (size %d)\n", filename, addr, size);
 
 	ret = ubifs_load(filename, addr, size);
-	if (ret) {
+	if (ret)
 		printf("** File not found %s **\n", filename);
-		ret = CMD_RET_FAILURE;
-	}
 
-	return ret;
+	return ret ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(
diff --git a/cmd/usb.c b/cmd/usb.c
index 2ba056982c..7988e1cbdd 100644
--- a/cmd/usb.c
+++ b/cmd/usb.c
@@ -497,7 +497,7 @@ static int usb_test(struct usb_device *dev, int port, char* arg)
 
 	if (port > dev->maxchild) {
 		printf("Device is no hub or does not have %d ports.\n", port);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	switch (arg[0]) {
@@ -529,7 +529,7 @@ static int usb_test(struct usb_device *dev, int port, char* arg)
 	default:
 		printf("Unrecognized test mode: %s\nAvailable modes: "
 		       "J, K, S[E0_NAK], P[acket], F[orce_Enable]\n", arg);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (port)
@@ -543,11 +543,11 @@ static int usb_test(struct usb_device *dev, int port, char* arg)
 			    (mode << 8) | port,
 			    NULL, 0, USB_CNTL_TIMEOUT) == -1) {
 		printf("Error during SET_FEATURE.\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	} else {
 		printf("Test mode successfully set. Use 'usb start' "
 		       "to return to normal operation.\n");
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 }
 
@@ -637,37 +637,37 @@ static int do_usb(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 
 	if (strncmp(argv[1], "start", 5) == 0) {
 		if (usb_started)
-			return 0; /* Already started */
+			return CMD_RET_SUCCESS; /* Already started */
 		printf("starting USB...\n");
 		do_usb_start();
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 
 	if (strncmp(argv[1], "reset", 5) == 0) {
 		printf("resetting USB...\n");
 		if (do_usb_stop_keyboard(1) != 0)
-			return 1;
+			return CMD_RET_FAILURE;
 		usb_stop();
 		do_usb_start();
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 	if (strncmp(argv[1], "stop", 4) == 0) {
 		if (argc != 2)
 			console_assign(stdin, "serial");
 		if (do_usb_stop_keyboard(0) != 0)
-			return 1;
+			return CMD_RET_FAILURE;
 		printf("stopping USB..\n");
 		usb_stop();
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 	if (!usb_started) {
 		printf("USB is stopped. Please issue 'usb start' first.\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 	if (strncmp(argv[1], "tree", 4) == 0) {
 		puts("USB device tree:\n");
 		usb_show_tree();
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 	if (strncmp(argv[1], "inf", 3) == 0) {
 		if (argc == 2) {
@@ -683,7 +683,7 @@ static int do_usb(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 				usb_display_config(udev);
 			}
 #endif
-			return 0;
+			return CMD_RET_SUCCESS;
 		} else {
 			/*
 			 * With driver model this isn't right since we can
@@ -695,13 +695,13 @@ static int do_usb(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 			udev = usb_find_device(i);
 			if (udev == NULL) {
 				printf("*** No device available ***\n");
-				return 0;
+				return CMD_RET_SUCCESS;
 			} else {
 				usb_display_desc(udev);
 				usb_display_config(udev);
 			}
 		}
-		return 0;
+		return CMD_RET_SUCCESS;
 	}
 	if (strncmp(argv[1], "test", 4) == 0) {
 		if (argc < 5)
@@ -710,14 +710,14 @@ static int do_usb(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		udev = usb_find_device(i);
 		if (udev == NULL) {
 			printf("Device %d does not exist.\n", i);
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 		i = dectoul(argv[3], NULL);
 		return usb_test(udev, i, argv[4]);
 	}
 #ifdef CONFIG_USB_STORAGE
 	if (strncmp(argv[1], "stor", 4) == 0)
-		return usb_stor_info();
+		return usb_stor_info() ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 
 	return blk_common_cmd(argc, argv, UCLASS_USB, &usb_stor_curr_dev);
 #else
diff --git a/cmd/usb_mass_storage.c b/cmd/usb_mass_storage.c
index b7daaa6e8e..cfc4d22e25 100644
--- a/cmd/usb_mass_storage.c
+++ b/cmd/usb_mass_storage.c
@@ -59,7 +59,6 @@ static int ums_init(const char *devtype, const char *devnums_part_str)
 	struct blk_desc *block_dev;
 	struct disk_partition info;
 	int partnum;
-	int ret = -1;
 	struct ums *ums_new;
 
 	s = strdup(devnums_part_str);
@@ -124,16 +123,13 @@ static int ums_init(const char *devtype, const char *devnums_part_str)
 		ums_count++;
 	}
 
-	if (ums_count)
-		ret = 0;
-
 cleanup:
 	free(s);
 
-	if (ret < 0)
+	if (!ums_count)
 		ums_fini();
 
-	return ret;
+	return ums_count ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
 
 static int do_usb_mass_storage(struct cmd_tbl *cmdtp, int flag,
@@ -164,23 +160,22 @@ static int do_usb_mass_storage(struct cmd_tbl *cmdtp, int flag,
 
 	controller_index = (unsigned int)(simple_strtoul(
 				usb_controller,	NULL, 0));
-	if (usb_gadget_initialize(controller_index)) {
+
+	rc = usb_gadget_initialize(controller_index);
+	if (rc) {
 		pr_err("Couldn't init USB controller.\n");
-		rc = CMD_RET_FAILURE;
 		goto cleanup_ums_init;
 	}
 
 	rc = fsg_init(ums, ums_count, controller_index);
 	if (rc) {
 		pr_err("fsg_init failed\n");
-		rc = CMD_RET_FAILURE;
 		goto cleanup_board;
 	}
 
 	rc = g_dnl_register("usb_dnl_ums");
 	if (rc) {
 		pr_err("g_dnl_register failed\n");
-		rc = CMD_RET_FAILURE;
 		goto cleanup_board;
 	}
 
@@ -197,13 +192,11 @@ static int do_usb_mass_storage(struct cmd_tbl *cmdtp, int flag,
 		while (!g_dnl_board_usb_cable_connected()) {
 			if (ctrlc()) {
 				puts("\rCTRL+C - Operation aborted.\n");
-				rc = CMD_RET_SUCCESS;
 				goto cleanup_register;
 			}
 			if (!cable_ready_timeout) {
-				puts("\rUSB cable not detected.\n" \
-				     "Command exit.\n");
-				rc = CMD_RET_SUCCESS;
+				puts("\rUSB cable not detected.\nCommand exit.\n");
+				rc = -ETIMEDOUT;
 				goto cleanup_register;
 			}
 
@@ -224,10 +217,10 @@ static int do_usb_mass_storage(struct cmd_tbl *cmdtp, int flag,
 				printf("\rCheck USB cable connection\n");
 
 			/* Check CTRL+C */
-			if (rc == -EPIPE)
+			if (rc == -EPIPE) {
 				printf("\rCTRL+C - Operation aborted\n");
-
-			rc = CMD_RET_SUCCESS;
+				rc = 0;
+			}
 			goto cleanup_register;
 		}
 
@@ -241,7 +234,7 @@ cleanup_board:
 cleanup_ums_init:
 	ums_fini();
 
-	return rc;
+	return rc ? CMD_RET_FAILURE : CMD_RET_SUCCESS;
 }
 
 U_BOOT_CMD(ums, 4, 1, do_usb_mass_storage,
diff --git a/cmd/zfs.c b/cmd/zfs.c
index 6ef1b56ab1..a0b4b4c7a3 100644
--- a/cmd/zfs.c
+++ b/cmd/zfs.c
@@ -72,17 +72,17 @@ static int do_zfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 		break;
 
 	default:
-		return cmd_usage(cmdtp);
+		return CMD_RET_USAGE;
 	}
 
 	if (!filename) {
 		puts("** No boot file defined **\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	part = blk_get_device_part_str(argv[1], argv[2], &dev_desc, &info, 1);
 	if (part < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	dev = dev_desc->devnum;
 	printf("Loading file \"%s\" from %s device %d%c%c\n",
@@ -96,7 +96,7 @@ static int do_zfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 	zfile.device = &vdev;
 	if (zfs_open(&zfile, filename)) {
 		printf("** File not found %s **\n", filename);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if ((count < zfile.size) && (count != 0))
@@ -106,7 +106,7 @@ static int do_zfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 		printf("** Unable to read \"%s\" from %s %d:%d **\n",
 			   filename, argv[1], dev, part);
 		zfs_close(&zfile);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	zfs_close(&zfile);
@@ -117,7 +117,7 @@ static int do_zfs_load(struct cmd_tbl *cmdtp, int flag, int argc,
 	printf("%llu bytes read\n", zfile.size);
 	env_set_hex("filesize", zfile.size);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 
@@ -140,22 +140,21 @@ static int do_zfs_ls(struct cmd_tbl *cmdtp, int flag, int argc,
 	struct device_s vdev;
 
 	if (argc < 2)
-		return cmd_usage(cmdtp);
+		return CMD_RET_USAGE;
 
 	if (argc == 4)
 		filename = argv[3];
 
 	part = blk_get_device_part_str(argv[1], argv[2], &dev_desc, &info, 1);
 	if (part < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	zfs_set_blk_dev(dev_desc, &info);
 	vdev.part_length = info.size;
 
-	zfs_ls(&vdev, filename,
-		   zfs_print);
+	zfs_ls(&vdev, filename, zfs_print);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 
diff --git a/common/board_f.c b/common/board_f.c
index e6117a7ba5..7af11ea4d8 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -19,6 +19,7 @@
 #include <cyclic.h>
 #include <display_options.h>
 #include <dm.h>
+#include <elf.h>
 #include <env.h>
 #include <env_internal.h>
 #include <event.h>
@@ -727,6 +728,48 @@ static int fix_fdt(void)
 }
 #endif
 
+static int __maybe_unused check_rel_dyn(void)
+{
+	unsigned long img_start = (unsigned long)__image_copy_start;
+#ifndef CONFIG_ARM64
+	unsigned long img_end = (unsigned long)_image_binary_end;
+	const unsigned long rel_type = R_ARM_RELATIVE;
+	struct reloc_entry {
+		unsigned long addr;
+		unsigned long code;
+	};
+#else
+	unsigned long img_end = (unsigned long)__image_copy_end;
+	const unsigned long rel_type = R_AARCH64_RELATIVE;
+	struct reloc_entry {
+		unsigned long addr;
+		unsigned long code;
+		unsigned long val;
+	};
+#endif
+	struct reloc_entry *rel_start = (void *)__rel_dyn_start;
+	struct reloc_entry *rel_end = (void *)__rel_dyn_end;
+	struct reloc_entry *p;
+	int errors = 0;
+
+	debug("Checking rel.dyn section from %p..%p\n", rel_start, rel_end);
+	for (p = rel_start; p < rel_end; p++) {
+		if (p->addr < img_start || p->addr > img_end) {
+			if (errors == 0)
+				pr_err("Relocation table has been corrupted! Fix your U-Boot sourcecode!\n");
+			pr_err("Entry at %p in relocation table (%08lx,%08lx) points outside the code to be relocated: %08lx..%08lx\n",
+			       p, p->addr, p->code, img_start, img_end - 1);
+			errors++;
+		}
+		if (p->code != rel_type)
+			pr_warn("Entry at %p in relocation table has unsupported relocation type: %08lx, %08lx\n",
+				p, p->addr, p->code);
+		if (errors >= 10)
+			hang();
+	}
+	return errors;
+}
+
 /* ARM calls relocate_code from its crt0.S */
 #if !defined(CONFIG_ARM) && !defined(CONFIG_SANDBOX) && \
 		!CONFIG_IS_ENABLED(X86_64)
@@ -950,6 +993,9 @@ static const init_fnc_t init_sequence_f[] = {
 	reloc_fdt,
 	reloc_bootstage,
 	reloc_bloblist,
+#if IS_ENABLED(CONFIG_CHECK_REL_DYN)
+	check_rel_dyn,
+#endif
 	setup_reloc,
 #if defined(CONFIG_X86) || defined(CONFIG_ARC)
 	copy_uboot_to_ram,
diff --git a/common/cli_readline.c b/common/cli_readline.c
index d6444f5fc1..f228971b4f 100644
--- a/common/cli_readline.c
+++ b/common/cli_readline.c
@@ -279,6 +279,12 @@ static int cread_line(const char *const prompt, char *buf, unsigned int *len,
 			first = 0;
 		}
 
+#ifdef CONFIG_SHOW_ACTIVITY
+		while (!tstc()) {	/* while no incoming data */
+			show_activity(0);
+			schedule();
+		}
+#endif
 		ichar = getcmd_getch();
 
 		/* ichar=0x0 when error occurs in U-Boot getc */
@@ -595,6 +601,12 @@ int cli_readline_into_buffer(const char *const prompt, char *buffer,
 			return -2;	/* timed out */
 		schedule();	/* Trigger watchdog, if needed */
 
+#ifdef CONFIG_SHOW_ACTIVITY
+		while (!tstc()) {
+			show_activity(0);
+			schedule();
+		}
+#endif
 		c = getchar();
 
 		/*
diff --git a/common/dfu.c b/common/dfu.c
index 96190889ab..f0ab537650 100644
--- a/common/dfu.c
+++ b/common/dfu.c
@@ -33,7 +33,7 @@ int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 	g_dnl_clear_detach();
 	ret = g_dnl_register(usb_dnl_gadget);
 	if (ret) {
-		pr_err("g_dnl_register failed");
+		pr_err("g_dnl_register failed\n");
 		return CMD_RET_FAILURE;
 	}
 
@@ -80,7 +80,7 @@ int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 			ret = dfu_flush(dfu_get_defer_flush(), NULL, 0, 0);
 			dfu_set_defer_flush(NULL);
 			if (ret) {
-				pr_err("Deferred dfu_flush() failed!");
+				pr_err("Deferred dfu_flush() failed!\n");
 				goto exit;
 			}
 		}
diff --git a/common/hash.c b/common/hash.c
index 9e53545dbd..b25c11fdf8 100644
--- a/common/hash.c
+++ b/common/hash.c
@@ -581,7 +581,7 @@ int hash_command(const char *algo_name, int flags, struct cmd_tbl *cmdtp,
 
 		if (algo->digest_size > HASH_MAX_DIGEST_SIZE) {
 			puts("HASH_MAX_DIGEST_SIZE exceeded\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 
 		output = memalign(ARCH_DMA_MINALIGN,
@@ -602,7 +602,7 @@ int hash_command(const char *algo_name, int flags, struct cmd_tbl *cmdtp,
 					flags & HASH_FLAG_ENV)) {
 				printf("ERROR: %s does not contain a valid "
 					"%s sum\n", *argv, algo->name);
-				return 1;
+				return CMD_RET_FAILURE;
 			}
 			if (memcmp(output, vsum, algo->digest_size) != 0) {
 				int i;
@@ -612,7 +612,7 @@ int hash_command(const char *algo_name, int flags, struct cmd_tbl *cmdtp,
 				for (i = 0; i < algo->digest_size; i++)
 					printf("%02x", vsum[i]);
 				puts(" ** ERROR **\n");
-				return 1;
+				return CMD_RET_FAILURE;
 			}
 		} else {
 			hash_show(algo, addr, len, output);
@@ -642,7 +642,7 @@ int hash_command(const char *algo_name, int flags, struct cmd_tbl *cmdtp,
 		}
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 #endif /* CONFIG_CMD_HASH || CONFIG_CMD_SHA1SUM || CONFIG_CMD_CRC32) */
 #endif /* !USE_HOSTCC */
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index d774c930a8..893b014eb9 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -1406,6 +1406,7 @@ endchoice
 config SPL_USB_SDP_SUPPORT
 	bool "Support SDP (Serial Download Protocol)"
 	depends on SPL_SERIAL
+	imply SPL_USB_HOST_SUPPORT if CI_UDC
 	help
 	  Enable Serial Download Protocol (SDP) device support in SPL. This
 	  allows to download images into memory and execute (jump to) them
@@ -1422,7 +1423,6 @@ endif
 
 config SPL_WATCHDOG
 	bool "Support watchdog drivers"
-	imply SPL_WDT if !HW_WATCHDOG
 	help
 	  Enable support for watchdog drivers in SPL. A watchdog is
 	  typically a hardware peripheral which can reset the system when it
diff --git a/common/spl/spl.c b/common/spl/spl.c
index 22d2a0621e..a9dad4f094 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -534,6 +534,8 @@ static int spl_common_init(bool setup_malloc)
 		gd->malloc_ptr = 0;
 	}
 #endif
+pr_info("Using %08lx..%08lx for initial malloc space\n",
+	gd->malloc_base, gd->malloc_base + gd->malloc_limit - 1);
 	ret = bootstage_init(u_boot_first_phase());
 	if (ret) {
 		debug("%s: Failed to set up bootstage: ret=%d\n", __func__,
@@ -697,7 +699,7 @@ static int boot_from_devices(struct spl_image_info *spl_image,
 		    !IS_ENABLED(CONFIG_SILENT_CONSOLE)) {
 			if (loader)
-				printf("Trying to boot from %s\n",
-				       spl_loader_name(loader));
+				debug("Trying to boot from %s\n",
+				      spl_loader_name(loader));
 			else if (CONFIG_IS_ENABLED(SHOW_ERRORS))
 				printf(SPL_TPL_PROMPT
 				       "Unsupported Boot Device %d\n",
diff --git a/common/usb_hub.c b/common/usb_hub.c
index 95f1449b5c..13e5a39b16 100644
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -167,7 +167,7 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 {
 	int i;
 	struct usb_device *dev;
-	unsigned pgood_delay = hub->desc.bPwrOn2PwrGood * 2;
+	unsigned long pgood_delay = hub->desc.bPwrOn2PwrGood * 2;
 	const char *env;
 
 	dev = hub->pusb_dev;
@@ -197,14 +197,14 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 	env = env_get("usb_pgood_delay");
 	if (env)
 		pgood_delay = max(pgood_delay,
-			          (unsigned)simple_strtol(env, NULL, 0));
+				  simple_strtoul(env, NULL, 0));
-	debug("pgood_delay=%dms\n", pgood_delay);
+	debug("pgood_delay=%ldms\n", pgood_delay);
 
 	/*
 	 * Do a minimum delay of the larger value of 100ms or pgood_delay
 	 * so that the power can stablize before the devices are queried
 	 */
-	hub->query_delay = get_timer(0) + max(100, (int)pgood_delay);
+	hub->query_delay = get_timer(0) + max(100UL, pgood_delay);
 
 	/*
 	 * Record the power-on timeout here. The max. delay (timeout)
@@ -213,9 +213,9 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 	 * usb_hub_configure() later.
 	 */
 	hub->connect_timeout = hub->query_delay + 1000;
-	debug("devnum=%d poweron: query_delay=%d connect_timeout=%d\n",
-	      dev->devnum, max(100, (int)pgood_delay),
-	      max(100, (int)pgood_delay) + 1000);
+	debug("devnum=%d poweron: query_delay=%lu connect_timeout=%lu\n",
+	      dev->devnum, max(100UL, pgood_delay),
+	      max(100UL, pgood_delay) + 1000);
 }
 
 #if !CONFIG_IS_ENABLED(DM_USB)
diff --git a/disk/part_efi.c b/disk/part_efi.c
index 18f7e58405..602a4d51f6 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -22,7 +22,9 @@
 #include <ide.h>
 #include <malloc.h>
 #include <memalign.h>
+#include <mmc.h>
 #include <part_efi.h>
+#include <dm/device.h>
 #include <dm/ofnode.h>
 #include <linux/compiler.h>
 #include <linux/ctype.h>
@@ -407,6 +409,57 @@ int write_gpt_table(struct blk_desc *dev_desc,
 	return -EIO;
 }
 
+#if CONFIG_IS_ENABLED(MMC_WRITE)
+static int gpt_align_to_mmc_erasegrp(struct blk_desc *blkdev, gpt_entry *gpt_e)
+{
+	struct mmc *mmc = find_mmc_device(blkdev->devnum);
+
+	if (!mmc) {
+		printf("Failed to find mmc device for blkdev\n");
+		return -ENODEV;
+	}
+	gpt_e->ending_lba -= (gpt_e->ending_lba + 1) % mmc->erase_grp_size;
+	return 0;
+}
+
+static int gpt_check_alignment(struct blk_desc *blkdev,
+			       struct disk_partition *partitions,
+			       gpt_entry *gpt_e, int num_parts)
+{
+	int ret = 0;
+	struct mmc *mmc = find_mmc_device(blkdev->devnum);
+	int i;
+
+	if (!mmc) {
+		printf("Failed to find mmc device for blkdev\n");
+		return -ENODEV;
+	}
+	for (i = 0; i < num_parts; i++) {
+		if (gpt_e[i].starting_lba % mmc->erase_grp_size ||
+		    (gpt_e[i].ending_lba + 1) % mmc->erase_grp_size) {
+			printf("Partition %d (%s) 0x%llx..0x%llx is not aligned to an MMC erase block\n",
+			       i, partitions[i].name, gpt_e[i].starting_lba,
+			       gpt_e[i].ending_lba);
+			ret = -EINVAL;
+		}
+	}
+	return ret;
+}
+#else
+static inline int gpt_check_alignment(struct blk_desc *blkdev,
+				      struct disk_partition *partitions,
+				      gpt_entry *gpt_e, int num_parts)
+{
+	return 0;
+}
+
+static inline int gpt_align_to_mmc_erasegrp(struct blk_desc *blkdev,
+					    gpt_entry *gpt_e)
+{
+	return 0;
+}
+#endif
+
 int gpt_fill_pte(struct blk_desc *dev_desc,
 		 gpt_header *gpt_h, gpt_entry *gpt_e,
 		 struct disk_partition *partitions, int parts)
@@ -461,11 +514,19 @@ int gpt_fill_pte(struct blk_desc *dev_desc,
 			return -E2BIG;
 		}
 		/* partition ending lba */
-		if ((i == parts - 1) && (size == 0))
-			/* extend the last partition to maximuim */
+		if ((i == parts - 1) && size == 0) {
+			/* extend the last partition to maximum */
 			gpt_e[i].ending_lba = gpt_h->last_usable_lba;
-		else
+			if (dev_desc->uclass_id == UCLASS_MMC) {
+				int ret = gpt_align_to_mmc_erasegrp(dev_desc,
+								    &gpt_e[i]);
+				if (ret)
+					return ret;
+			}
+			printf("MMC ending LBA=%08llx\n", gpt_e[i].ending_lba);
+		} else {
 			gpt_e[i].ending_lba = cpu_to_le64(offset - 1);
+		}
 
 #ifdef CONFIG_PARTITION_TYPE_GUID
 		str_type_guid = partitions[i].type_guid;
@@ -523,6 +584,8 @@ int gpt_fill_pte(struct blk_desc *dev_desc,
 		      __func__, partitions[i].name, i,
 		      offset, i, size);
 	}
+	if (dev_desc->uclass_id == UCLASS_MMC)
+		return gpt_check_alignment(dev_desc, partitions, gpt_e, parts);
 
 	return 0;
 }
@@ -549,7 +612,7 @@ static uint32_t partition_entries_offset(struct blk_desc *dev_desc)
 
 #if defined(CONFIG_OF_CONTROL)
 	/*
-	 * Allow the offset of the first partition entires (in bytes
+	 * Allow the offset of the first partition entry (in bytes
 	 * from the start of the device) to be specified as a property
 	 * of the device tree '/config' node.
 	 */
diff --git a/drivers/adc/adc-uclass.c b/drivers/adc/adc-uclass.c
index 67137ffb34..a6dc989f36 100644
--- a/drivers/adc/adc-uclass.c
+++ b/drivers/adc/adc-uclass.c
@@ -65,7 +65,7 @@ static int adc_supply_enable(struct udevice *dev)
 	}
 
 	if (ret)
-		pr_err("%s: can't enable %s-supply!", dev->name, supply_type);
+		pr_err("%s: can't enable %s-supply!\n", dev->name, supply_type);
 
 	return ret;
 }
@@ -425,12 +425,12 @@ static int adc_pre_probe(struct udevice *dev)
 	/* Set ADC VDD plat: polarity, uV, regulator (phandle). */
 	ret = adc_vdd_plat_set(dev);
 	if (ret)
-		pr_err("%s: Can't update Vdd. Error: %d", dev->name, ret);
+		pr_err("%s: Can't update Vdd. Error: %d\n", dev->name, ret);
 
 	/* Set ADC VSS plat: polarity, uV, regulator (phandle). */
 	ret = adc_vss_plat_set(dev);
 	if (ret)
-		pr_err("%s: Can't update Vss. Error: %d", dev->name, ret);
+		pr_err("%s: Can't update Vss. Error: %d\n", dev->name, ret);
 
 	return 0;
 }
diff --git a/drivers/ddr/imx/phy/ddrphy_utils.c b/drivers/ddr/imx/phy/ddrphy_utils.c
index b852c870f9..ead0eb3bcc 100644
--- a/drivers/ddr/imx/phy/ddrphy_utils.c
+++ b/drivers/ddr/imx/phy/ddrphy_utils.c
@@ -11,14 +11,27 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/ddr.h>
 #include <asm/arch/sys_proto.h>
+#include <linux/delay.h>
 
-static inline void poll_pmu_message_ready(void)
+#define MAX_LOOPS	100000
+static int min_loops = INT_MAX;
+
+static inline int poll_pmu_message_ready(void)
 {
+	int loops = MAX_LOOPS;
 	unsigned int reg;
 
 	do {
 		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0004));
-	} while (reg & 0x1);
+		if (!(reg & 1))
+			break;
+		udelay(1);
+		loops--;
+	} while (loops > 0);
+	if (loops < min_loops) {
+		min_loops = loops;
+	}
+	return loops;
 }
 
 static inline void ack_pmu_message_receive(void)
@@ -34,15 +47,16 @@ static inline void ack_pmu_message_receive(void)
 	reg32_write(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0031), 0x1);
 }
 
-static inline unsigned int get_mail(void)
+static inline int get_mail(void)
 {
 	unsigned int reg;
 
-	poll_pmu_message_ready();
-
-	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0032));
-
-	ack_pmu_message_receive();
+	if (poll_pmu_message_ready()) {
+		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0032));
+		ack_pmu_message_receive();
+	} else {
+		return -1;
+	}
 
 	return reg;
 }
@@ -51,15 +65,15 @@ static inline unsigned int get_stream_message(void)
 {
 	unsigned int reg, reg2;
 
-	poll_pmu_message_ready();
-
-	reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0032));
+	if (poll_pmu_message_ready()) {
+		reg = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0032));
+		reg2 = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0034));
+		reg2 = (reg2 << 16) | reg;
 
-	reg2 = reg32_read(IP2APB_DDRPHY_IPS_BASE_ADDR(0) + ddrphy_addr_remap(0xd0034));
-
-	reg2 = (reg2 << 16) | reg;
-
-	ack_pmu_message_receive();
+		ack_pmu_message_receive();
+	} else {
+		return 0;
+	}
 
 	return reg2;
 }
@@ -87,10 +101,15 @@ static inline void decode_streaming_message(void)
 
 int wait_ddrphy_training_complete(void)
 {
-	unsigned int mail;
+	int mail;
+	static int last_loops = -1;
 
 	while (1) {
 		mail = get_mail();
+		if (min_loops != last_loops) {
+			printf("max_loops=%d\n", MAX_LOOPS - min_loops);
+			last_loops = min_loops;
+		}
 		decode_major_message(mail);
 		if (mail == 0x08) {
 			decode_streaming_message();
@@ -100,6 +119,12 @@ int wait_ddrphy_training_complete(void)
 		} else if (mail == 0xff) {
 			printf("Training FAILED\n");
 			return -1;
+		} else if (mail < 0) {
+			puts("Timeout waiting for DDR training to complete\n");
+			return -1;
+		} else {
+			debug("%s: Unhandled return value %d from get_mail()\n",
+			      __func__, mail);
 		}
 	}
 }
diff --git a/drivers/ddr/imx/phy/helper.c b/drivers/ddr/imx/phy/helper.c
index e9e0294f87..5d4c9fc29d 100644
--- a/drivers/ddr/imx/phy/helper.c
+++ b/drivers/ddr/imx/phy/helper.c
@@ -2,6 +2,8 @@
 /*
  * Copyright 2018 NXP
  */
+#undef DEBUG
+#define DEBUG
 
 #include <common.h>
 #include <binman_sym.h>
@@ -50,5 +52,6 @@ void ddr_load_train_firmware(enum fw_type type)
 	unsigned long dmem_start;
 
+debug("%s@%d: imem: %08lx..%08lx\n", __func__, __LINE__, imem_start, imem_start + imem_len - 1);
 #ifdef CONFIG_SPL_OF_CONTROL
 	if (gd->fdt_blob && !fdt_check_header(gd->fdt_blob)) {
 		imem_start = roundup((unsigned long)&_end +
@@ -59,4 +62,6 @@ void ddr_load_train_firmware(enum fw_type type)
 #endif
 
 	dmem_start = imem_start + IMEM_LEN;
+debug("%s@%d: imem: %08lx..%08lx\n", __func__, __LINE__, imem_start, imem_start + IMEM_LEN - 1);
+debug("%s@%d: dmem: %08lx..%08lx\n", __func__, __LINE__, dmem_start, dmem_start + dmem_len - 1);
 
@@ -108,42 +119,46 @@ void ddr_load_train_firmware(enum fw_type type)
 	debug("check ddr_pmu_train_imem code\n");
 	pr_from32 = imem_start;
 	pr_to32 = IMEM_OFFSET_ADDR;
-	for (i = 0x0; i < IMEM_LEN; ) {
+	for (i = 0x0; i < IMEM_LEN; i += 4) {
 		tmp32 = (readw(DDR_TRAIN_CODE_BASE_ADDR + ddrphy_addr_remap(pr_to32)) & 0x0000ffff);
 		pr_to32 += 1;
 		tmp32 += ((readw(DDR_TRAIN_CODE_BASE_ADDR + ddrphy_addr_remap(pr_to32)) & 0x0000ffff) << 16);
 
 		if (tmp32 != readl(pr_from32)) {
-			debug("%lx %lx\n", pr_from32, pr_to32);
+			if (error < 256)
+				printf("memory error: %08lx %08lx: %08x -> %08x\n",
+				       pr_from32, pr_to32, tmp32, readl(pr_from32));
 			error++;
 		}
 		pr_from32 += 4;
 		pr_to32 += 1;
-		i += 4;
 	}
 	if (error)
-		printf("check ddr_pmu_train_imem code fail=%d\n", error);
+		printf("check ddr_pmu_train_imem code failed with %d errors\n",
+		       error);
 	else
 		debug("check ddr_pmu_train_imem code pass\n");
 
-	debug("check ddr4_pmu_train_dmem code\n");
+	debug("check ddr_pmu_train_dmem code\n");
 	pr_from32 = dmem_start;
 	pr_to32 = DMEM_OFFSET_ADDR;
-	for (i = 0x0; i < DMEM_LEN;) {
+	for (i = 0x0; i < DMEM_LEN; i += 4) {
 		tmp32 = (readw(DDR_TRAIN_CODE_BASE_ADDR + ddrphy_addr_remap(pr_to32)) & 0x0000ffff);
 		pr_to32 += 1;
 		tmp32 += ((readw(DDR_TRAIN_CODE_BASE_ADDR + ddrphy_addr_remap(pr_to32)) & 0x0000ffff) << 16);
 		if (tmp32 != readl(pr_from32)) {
-			debug("%lx %lx\n", pr_from32, pr_to32);
+			if (error < 256)
+				printf("memory error: %08lx %08lx\n",
+				       pr_from32, pr_to32);
 			error++;
 		}
 		pr_from32 += 4;
 		pr_to32 += 1;
-		i += 4;
 	}
 
 	if (error)
-		printf("check ddr_pmu_train_dmem code fail=%d", error);
+		printf("check ddr_pmu_train_dmem code failed with %d errors\n",
+		       error);
 	else
 		debug("check ddr_pmu_train_dmem code pass\n");
 }
diff --git a/drivers/i2c/mxc_i2c.c b/drivers/i2c/mxc_i2c.c
index f80ff5383b..1a6699dbbc 100644
--- a/drivers/i2c/mxc_i2c.c
+++ b/drivers/i2c/mxc_i2c.c
@@ -519,7 +519,10 @@ static int i2c_write_data(struct mxc_i2c_bus *i2c_bus, u8 chip, const u8 *buf,
 	int i, ret = 0;
 
 	debug("i2c_write_data: chip=0x%x, len=0x%x\n", chip, len);
-	debug("write_data: ");
+	if (!len)
+		return 0;
+
+	debug("write_data:");
 	/* use rc for counter */
 	for (i = 0; i < len; ++i)
 		debug(" 0x%02x", buf[i]);
@@ -563,6 +566,8 @@ static int i2c_read_data(struct mxc_i2c_bus *i2c_bus, uchar chip, uchar *buf,
 	/* dummy read to clear ICF */
 	readb(base + (I2DR << reg_shift));
 
+	if (len)
+		debug("read_data:");
 	/* read data */
 	for (i = 0; i < len; i++) {
 		ret = wait_for_sr_state(i2c_bus, ST_IIF);
@@ -740,7 +745,8 @@ void bus_i2c_init(int index, int speed, int unused,
 	int ret;
 
 	if (index >= ARRAY_SIZE(mxc_i2c_buses)) {
-		debug("Error i2c index\n");
+		printf("I2C index %u out of range 0..%zu\n",
+		       index, ARRAY_SIZE(mxc_i2c_buses));
 		return;
 	}
 
@@ -765,7 +771,7 @@ void bus_i2c_init(int index, int speed, int unused,
 
 	ret = enable_i2c_clk(1, index);
 	if (ret < 0) {
-		debug("I2C-%d clk fail to enable.\n", index);
+		printf("Failed to enable I2C-%d clk: %d\n", index, ret);
 		return;
 	}
 
@@ -914,7 +920,7 @@ static int mxc_i2c_probe(struct udevice *bus)
 	 */
 	ret = fdt_stringlist_search(fdt, node, "pinctrl-names", "gpio");
 	if (ret < 0) {
-		debug("i2c bus %d at 0x%2lx, no gpio pinctrl state.\n",
+		debug("i2c bus %d at 0x%08lx, no gpio pinctrl state.\n",
 		      dev_seq(bus), i2c_bus->base);
 	} else {
 		ret = gpio_request_by_name_nodev(offset_to_ofnode(node),
@@ -927,7 +933,7 @@ static int mxc_i2c_probe(struct udevice *bus)
 		    !dm_gpio_is_valid(&i2c_bus->scl_gpio) ||
 		    ret || ret2) {
 			dev_err(bus,
-				"i2c bus %d at 0x%2lx, fail to request scl/sda gpio\n",
+				"i2c bus %d at 0x%08lx, failed to request scl/sda gpios\n",
 				dev_seq(bus), i2c_bus->base);
 			return -EINVAL;
 		}
@@ -954,7 +960,8 @@ static int mxc_i2c_probe_chip(struct udevice *bus, u32 chip_addr,
 
 	ret = i2c_init_transfer(i2c_bus, chip_addr, 0, 0);
 	if (ret < 0) {
-		debug("%s failed, ret = %d\n", __func__, ret);
+		if (ret != -EREMOTEIO)
+			printf("i2c_init_transfer error: %d\n", ret);
 		return ret;
 	}
 
@@ -978,7 +985,7 @@ static int mxc_i2c_xfer(struct udevice *bus, struct i2c_msg *msg, int nmsgs)
 	 */
 	ret = i2c_init_transfer(i2c_bus, msg->addr, 0, -1);
 	if (ret < 0) {
-		debug("i2c_init_transfer error: %d\n", ret);
+		printf("i2c_init_transfer error: %d\n", ret);
 		return ret;
 	}
 
@@ -1021,7 +1028,7 @@ static int mxc_i2c_xfer(struct udevice *bus, struct i2c_msg *msg, int nmsgs)
 	}
 
 	if (ret)
-		debug("i2c_write: error sending\n");
+		printf("i2c_write: error sending\n");
 
 	i2c_imx_stop(i2c_bus);
 
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 210703ea46..2037db58c2 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -14,6 +14,7 @@
 #include <dm.h>
 #include <log.h>
 #include <dm/device-internal.h>
+#include <dm/device_compat.h>
 #include <errno.h>
 #include <mmc.h>
 #include <part.h>
@@ -2931,7 +2932,11 @@ int mmc_start_init(struct mmc *mmc)
 	if (no_card) {
 		mmc->has_init = 0;
 #if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+#if CONFIG_IS_ENABLED(DM_MMC)
+		dev_err(mmc->dev, "no card present\n");
+#else
 		pr_err("MMC: no card present\n");
+#endif
 #endif
 		return -ENOMEDIUM;
 	}
@@ -2977,7 +2982,8 @@ int mmc_init(struct mmc *mmc)
 
 	if (!mmc->init_in_progress)
 		err = mmc_start_init(mmc);
-
+	if (err == -ENOMEDIUM)
+		return err;
 	if (!err)
 		err = mmc_complete_init(mmc);
 	if (err)
@@ -3040,26 +3046,57 @@ static int mmc_probe(struct bd_info *bis)
 {
 	int ret, i;
 	struct uclass *uc;
+	struct uclass *ub;
 	struct udevice *dev;
 
 	ret = uclass_get(UCLASS_MMC, &uc);
 	if (ret)
 		return ret;
 
+	ret = uclass_get(UCLASS_BLK, &ub);
+	if (ret)
+		return ret;
+
 	/*
 	 * Try to add them in sequence order. Really with driver model we
 	 * should allow holes, but the current MMC list does not allow that.
 	 * So if we request 0, 1, 3 we will get 0, 1, 2.
 	 */
 	for (i = 0; ; i++) {
+		struct udevice *blkdev;
+
 		ret = uclass_get_device_by_seq(UCLASS_MMC, i, &dev);
+
+		if (ret == -ENODEV)
+			debug("mmc%d device not found\n", i);
+		else
+			dev_dbg(dev, "Probing mmc%d %p...\n", i, dev);
 		if (ret == -ENODEV)
 			break;
-	}
-	uclass_foreach_dev(dev, uc) {
 		ret = device_probe(dev);
-		if (ret)
-			pr_err("%s - probe failed: %d\n", dev->name, ret);
+		if (ret) {
+			if (ret != -ENOMEDIUM)
+				dev_err(dev, "probe failed: %d\n", ret);
+			else
+				dev_info(dev, "no medium ");
+			continue;
+		}
+#ifdef CONFIG_BLK
+		for (device_find_first_child(dev, &blkdev); blkdev;
+		     device_find_next_child(&blkdev)) {
+			if (device_get_uclass_id(blkdev) == UCLASS_BLK)
+				break;
+		}
+		if (!blkdev) {
+			dev_err(dev, "mmc%d: no BLK device found\n", i);
+			continue;
+		}
+		ret = device_probe(blkdev);
+		if (ret) {
+			if (ret != -ENOMEDIUM)
+				dev_err(dev, "probe failed: %d\n", ret);
+		}
+#endif
 	}
 
 	return 0;
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 029bf3872a..3fe4769ee9 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -212,6 +212,7 @@ config DWC_ETH_QOS_STM32
 	bool "Synopsys DWC Ethernet QOS device support for STM32"
 	depends on DWC_ETH_QOS
 	select DM_ETH_PHY
+	select REGMAP
 	default y if ARCH_STM32MP
 	help
 	  The Synopsys Designware Ethernet QOS IP block with the specific
diff --git a/drivers/net/dwc_eth_qos.c b/drivers/net/dwc_eth_qos.c
index afc47b56ff..3c3614831c 100644
--- a/drivers/net/dwc_eth_qos.c
+++ b/drivers/net/dwc_eth_qos.c
@@ -42,16 +42,19 @@
 #include <net.h>
 #include <netdev.h>
 #include <phy.h>
+#include <regmap.h>
 #include <reset.h>
+#include <syscon.h>
 #include <wait_bit.h>
 #include <asm/cache.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <eth_phy.h>
+#include <dm/device_compat.h>
 #if defined(CONFIG_IMX8MP) || defined(CONFIG_IMX8DXL) || defined(CONFIG_IMX93)
 #include <asm/arch/clock.h>
 #include <asm/mach-imx/sys_proto.h>
 #endif
 #include <linux/bitops.h>
 #include <linux/delay.h>
 
@@ -121,5 +127,16 @@ struct eqos_priv {
 	bool started;
 	bool reg_access_ok;
 	bool clk_ck_enabled;
+	u32 phy_addr;
+	int phy_reset_duration;
+	int phy_reset_post_delay;
+#if IS_ENABLED(CONFIG_REGMAP)
+	struct regmap *gpr;
+	u32 gpr_reg:8;
+	u32 rgmii_bit:5;
+	u32 intf_sel_bit:5;
+#else
+	void *gpr;
+#endif
 };
 
@@ -158,7 +162,7 @@ static int eqos_mdio_read(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		pr_err("MDIO not idle at entry");
+		pr_err("MDIO not idle at entry\n");
 		return ret;
 	}
 
@@ -178,7 +182,7 @@ static int eqos_mdio_read(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		pr_err("MDIO read didn't complete");
+		pr_err("MDIO read didn't complete\n");
 		return ret;
 	}
 
@@ -202,7 +206,7 @@ static int eqos_mdio_write(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		pr_err("MDIO not idle at entry");
+		pr_err("MDIO not idle at entry\n");
 		return ret;
 	}
 
@@ -224,7 +228,7 @@ static int eqos_mdio_write(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 
 	ret = eqos_mdio_wait_idle(eqos);
 	if (ret) {
-		pr_err("MDIO read didn't complete");
+		pr_err("MDIO read didn't complete\n");
 		return ret;
 	}
 
@@ -233,7 +237,6 @@ static int eqos_mdio_write(struct mii_dev *bus, int mdio_addr, int mdio_devad,
 
 static int eqos_start_clks_tegra186(struct udevice *dev)
 {
-#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
 
@@ -241,45 +244,43 @@ static int eqos_start_clks_tegra186(struct udevice *dev)
 
 	ret = clk_enable(&eqos->clk_slave_bus);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_slave_bus) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_slave_bus) failed: %d\n", ret);
 		goto err;
 	}
 
 	ret = clk_enable(&eqos->clk_master_bus);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_master_bus) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_master_bus) failed: %d\n", ret);
 		goto err_disable_clk_slave_bus;
 	}
 
 	ret = clk_enable(&eqos->clk_rx);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_rx) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_rx) failed: %d\n", ret);
 		goto err_disable_clk_master_bus;
 	}
 
 	ret = clk_enable(&eqos->clk_ptp_ref);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_ptp_ref) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_ptp_ref) failed: %d\n", ret);
 		goto err_disable_clk_rx;
 	}
 
 	ret = clk_set_rate(&eqos->clk_ptp_ref, 125 * 1000 * 1000);
 	if (ret < 0) {
-		pr_err("clk_set_rate(clk_ptp_ref) failed: %d", ret);
+		dev_err(dev, "clk_set_rate(clk_ptp_ref) failed: %d\n", ret);
 		goto err_disable_clk_ptp_ref;
 	}
 
 	ret = clk_enable(&eqos->clk_tx);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_tx) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_tx) failed: %d\n", ret);
 		goto err_disable_clk_ptp_ref;
 	}
-#endif
 
 	debug("%s: OK\n", __func__);
 	return 0;
 
-#ifdef CONFIG_CLK
 err_disable_clk_ptp_ref:
 	clk_disable(&eqos->clk_ptp_ref);
 err_disable_clk_rx:
@@ -291,12 +292,10 @@ err_disable_clk_slave_bus:
 err:
 	debug("%s: FAILED: %d\n", __func__, ret);
 	return ret;
-#endif
 }
 
 static int eqos_start_clks_stm32(struct udevice *dev)
 {
-#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
 
@@ -304,36 +303,34 @@ static int eqos_start_clks_stm32(struct udevice *dev)
 
 	ret = clk_enable(&eqos->clk_master_bus);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_master_bus) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_master_bus) failed: %d\n", ret);
 		goto err;
 	}
 
 	ret = clk_enable(&eqos->clk_rx);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_rx) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_rx) failed: %d\n", ret);
 		goto err_disable_clk_master_bus;
 	}
 
 	ret = clk_enable(&eqos->clk_tx);
 	if (ret < 0) {
-		pr_err("clk_enable(clk_tx) failed: %d", ret);
+		dev_err(dev, "clk_enable(clk_tx) failed: %d\n", ret);
 		goto err_disable_clk_rx;
 	}
 
 	if (clk_valid(&eqos->clk_ck) && !eqos->clk_ck_enabled) {
 		ret = clk_enable(&eqos->clk_ck);
 		if (ret < 0) {
-			pr_err("clk_enable(clk_ck) failed: %d", ret);
+			dev_err(dev, "clk_enable(clk_ck) failed: %d\n", ret);
 			goto err_disable_clk_tx;
 		}
 		eqos->clk_ck_enabled = true;
 	}
-#endif
 
 	debug("%s: OK\n", __func__);
 	return 0;
 
-#ifdef CONFIG_CLK
 err_disable_clk_tx:
 	clk_disable(&eqos->clk_tx);
 err_disable_clk_rx:
@@ -343,12 +340,10 @@ err_disable_clk_master_bus:
 err:
 	debug("%s: FAILED: %d\n", __func__, ret);
 	return ret;
-#endif
 }
 
 static int eqos_stop_clks_tegra186(struct udevice *dev)
 {
-#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 
 	debug("%s(dev=%p):\n", __func__, dev);
@@ -358,7 +353,6 @@ static int eqos_stop_clks_tegra186(struct udevice *dev)
 	clk_disable(&eqos->clk_rx);
 	clk_disable(&eqos->clk_master_bus);
 	clk_disable(&eqos->clk_slave_bus);
-#endif
 
 	debug("%s: OK\n", __func__);
 	return 0;
@@ -366,7 +360,6 @@ static int eqos_stop_clks_tegra186(struct udevice *dev)
 
 static int eqos_stop_clks_stm32(struct udevice *dev)
 {
-#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 
 	debug("%s(dev=%p):\n", __func__, dev);
@@ -374,7 +367,6 @@ static int eqos_stop_clks_stm32(struct udevice *dev)
 	clk_disable(&eqos->clk_tx);
 	clk_disable(&eqos->clk_rx);
 	clk_disable(&eqos->clk_master_bus);
-#endif
 
 	debug("%s: OK\n", __func__);
 	return 0;
@@ -389,7 +381,9 @@ static int eqos_start_resets_tegra186(struct udevice *dev)
 
 	ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 1);
 	if (ret < 0) {
-		pr_err("dm_gpio_set_value(phy_reset, assert) failed: %d", ret);
+		dev_err(dev,
+			"dm_gpio_set_value(phy_reset, assert) failed: %d\n",
+			ret);
 		return ret;
 	}
 
@@ -397,13 +391,15 @@ static int eqos_start_resets_tegra186(struct udevice *dev)
 
 	ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 0);
 	if (ret < 0) {
-		pr_err("dm_gpio_set_value(phy_reset, deassert) failed: %d", ret);
+		dev_err(dev,
+			"dm_gpio_set_value(phy_reset, deassert) failed: %d\n",
+			ret);
 		return ret;
 	}
 
 	ret = reset_assert(&eqos->reset_ctl);
 	if (ret < 0) {
-		pr_err("reset_assert() failed: %d", ret);
+		dev_err(dev, "reset_assert() failed: %d\n", ret);
 		return ret;
 	}
 
@@ -411,7 +407,7 @@ static int eqos_start_resets_tegra186(struct udevice *dev)
 
 	ret = reset_deassert(&eqos->reset_ctl);
 	if (ret < 0) {
-		pr_err("reset_deassert() failed: %d", ret);
+		dev_err(dev, "reset_deassert() failed: %d\n", ret);
 		return ret;
 	}
 
@@ -419,6 +415,39 @@ static int eqos_start_resets_tegra186(struct udevice *dev)
 	return 0;
 }
 
+static int eqos_start_resets_generic(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	int ret;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+	if (!dm_gpio_is_valid(&eqos->phy_reset_gpio))
+		return 0;
+
+	dev_dbg(dev, "%s@%d: Asserting PHY reset\n", __func__, __LINE__);
+	ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 1);
+	if (ret < 0) {
+		dev_err(dev, "failed to assert phy_reset GPIO: %d\n",
+			ret);
+		return ret;
+	}
+
+	udelay(eqos->phy_reset_duration);
+
+	dev_dbg(dev, "%s@%d: Deasserting PHY reset\n", __func__, __LINE__);
+	ret = dm_gpio_set_value(&eqos->phy_reset_gpio, 0);
+	if (ret < 0) {
+		dev_err(dev, "failed to deassert phy_reset GPIO: %d\n",
+			ret);
+		return ret;
+	}
+
+	udelay(eqos->phy_reset_post_delay);
+
+	return 0;
+}
+
 static int eqos_stop_resets_tegra186(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -429,6 +458,17 @@ static int eqos_stop_resets_tegra186(struct udevice *dev)
 	return 0;
 }
 
+static int eqos_stop_resets_generic(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+
+	if (!dm_gpio_is_valid(&eqos->phy_reset_gpio))
+		return 0;
+
+	dm_gpio_set_value(&eqos->phy_reset_gpio, 1);
+	return 0;
+}
+
 static int eqos_calibrate_pads_tegra186(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -447,14 +487,14 @@ static int eqos_calibrate_pads_tegra186(struct udevice *dev)
 	ret = wait_for_bit_le32(&eqos->tegra186_regs->auto_cal_status,
 				EQOS_AUTO_CAL_STATUS_ACTIVE, true, 10, false);
 	if (ret) {
-		pr_err("calibrate didn't start");
+		dev_err(dev, "calibrate didn't start\n");
 		goto failed;
 	}
 
 	ret = wait_for_bit_le32(&eqos->tegra186_regs->auto_cal_status,
 				EQOS_AUTO_CAL_STATUS_ACTIVE, false, 10, false);
 	if (ret) {
-		pr_err("calibrate didn't finish");
+		dev_err(dev, "calibrate didn't finish\n");
 		goto failed;
 	}
 
@@ -483,24 +523,16 @@ static int eqos_disable_calibration_tegra186(struct udevice *dev)
 
 static ulong eqos_get_tick_clk_rate_tegra186(struct udevice *dev)
 {
-#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 
 	return clk_get_rate(&eqos->clk_slave_bus);
-#else
-	return 0;
-#endif
 }
 
 static ulong eqos_get_tick_clk_rate_stm32(struct udevice *dev)
 {
-#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 
 	return clk_get_rate(&eqos->clk_master_bus);
-#else
-	return 0;
-#endif
 }
 
 static int eqos_set_full_duplex(struct udevice *dev)
@@ -567,7 +599,6 @@ static int eqos_set_mii_speed_10(struct udevice *dev)
 
 static int eqos_set_tx_clk_speed_tegra186(struct udevice *dev)
 {
-#ifdef CONFIG_CLK
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	ulong rate;
 	int ret;
@@ -585,16 +616,16 @@ static int eqos_set_tx_clk_speed_tegra186(struct udevice *dev)
 		rate = 2.5 * 1000 * 1000;
 		break;
 	default:
-		pr_err("invalid speed %d", eqos->phy->speed);
+		dev_err(dev, "invalid speed %d\n", eqos->phy->speed);
 		return -EINVAL;
 	}
 
 	ret = clk_set_rate(&eqos->clk_tx, rate);
 	if (ret < 0) {
-		pr_err("clk_set_rate(tx_clk, %lu) failed: %d", rate, ret);
+		dev_err(dev, "clk_set_rate(tx_clk, %lu) failed: %d\n",
+			rate, ret);
 		return ret;
 	}
-#endif
 
 	return 0;
 }
@@ -612,7 +643,7 @@ static int eqos_adjust_link(struct udevice *dev)
 	else
 		ret = eqos_set_half_duplex(dev);
 	if (ret < 0) {
-		pr_err("eqos_set_*_duplex() failed: %d", ret);
+		dev_err(dev, "eqos_set_*_duplex() failed: %d\n", ret);
 		return ret;
 	}
 
@@ -630,32 +661,32 @@ static int eqos_adjust_link(struct udevice *dev)
 		ret = eqos_set_mii_speed_10(dev);
 		break;
 	default:
-		pr_err("invalid speed %d", eqos->phy->speed);
+		dev_err(dev, "invalid speed %d\n", eqos->phy->speed);
 		return -EINVAL;
 	}
 	if (ret < 0) {
-		pr_err("eqos_set_*mii_speed*() failed: %d", ret);
+		dev_err(dev, "eqos_set_*mii_speed*() failed: %d\n", ret);
 		return ret;
 	}
 
 	if (en_calibration) {
 		ret = eqos->config->ops->eqos_calibrate_pads(dev);
 		if (ret < 0) {
-			pr_err("eqos_calibrate_pads() failed: %d",
-			       ret);
+			dev_err(dev, "eqos_calibrate_pads() failed: %d\n",
+				ret);
 			return ret;
 		}
 	} else {
 		ret = eqos->config->ops->eqos_disable_calibration(dev);
 		if (ret < 0) {
-			pr_err("eqos_disable_calibration() failed: %d",
-			       ret);
+			dev_err(dev, "eqos_disable_calibration() failed: %d\n",
+				ret);
 			return ret;
 		}
 	}
 	ret = eqos->config->ops->eqos_set_tx_clk_speed(dev);
 	if (ret < 0) {
-		pr_err("eqos_set_tx_clk_speed() failed: %d", ret);
+		dev_err(dev, "eqos_set_tx_clk_speed() failed: %d\n", ret);
 		return ret;
 	}
 
@@ -719,113 +750,40 @@ static int eqos_read_rom_hwaddr(struct udevice *dev)
 	return !is_valid_ethaddr(pdata->enetaddr);
 }
 
-static int eqos_get_phy_addr(struct eqos_priv *priv, struct udevice *dev)
-{
-	struct ofnode_phandle_args phandle_args;
-	int reg;
-
-	if (dev_read_phandle_with_args(dev, "phy-handle", NULL, 0, 0,
-				       &phandle_args)) {
-		debug("Failed to find phy-handle");
-		return -ENODEV;
-	}
-
-	priv->phy_of_node = phandle_args.node;
-
-	reg = ofnode_read_u32_default(phandle_args.node, "reg", 0);
-
-	return reg;
-}
-
 static int eqos_start(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret, i;
-	ulong rate;
 	u32 val, tx_fifo_sz, rx_fifo_sz, tqs, rqs, pbl;
 	ulong last_rx_desc;
 	ulong desc_pad;
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
-	eqos->tx_desc_idx = 0;
-	eqos->rx_desc_idx = 0;
-
-	ret = eqos->config->ops->eqos_start_resets(dev);
-	if (ret < 0) {
-		pr_err("eqos_start_resets() failed: %d", ret);
+	if (!eqos->phy) {
+		dev_err(dev, "No PHY attached\n");
+		ret = -ENODEV;
 		goto err;
 	}
 
-	udelay(10);
-
-	eqos->reg_access_ok = true;
-
-	ret = wait_for_bit_le32(&eqos->dma_regs->mode,
-				EQOS_DMA_MODE_SWR, false,
-				eqos->config->swr_wait, false);
-	if (ret) {
-		pr_err("EQOS_DMA_MODE_SWR stuck");
-		goto err_stop_resets;
-	}
-
-	ret = eqos->config->ops->eqos_calibrate_pads(dev);
-	if (ret < 0) {
-		pr_err("eqos_calibrate_pads() failed: %d", ret);
-		goto err_stop_resets;
-	}
-	rate = eqos->config->ops->eqos_get_tick_clk_rate(dev);
-
-	val = (rate / 1000000) - 1;
-	writel(val, &eqos->mac_regs->us_tic_counter);
-
-	/*
-	 * if PHY was already connected and configured,
-	 * don't need to reconnect/reconfigure again
-	 */
-	if (!eqos->phy) {
-		int addr = -1;
-		addr = eqos_get_phy_addr(eqos, dev);
-#ifdef DWC_NET_PHYADDR
-		addr = DWC_NET_PHYADDR;
-#endif
-		eqos->phy = phy_connect(eqos->mii, addr, dev,
-					eqos->config->interface(dev));
-		if (!eqos->phy) {
-			pr_err("phy_connect() failed");
-			goto err_stop_resets;
-		}
-
-		if (eqos->max_speed) {
-			ret = phy_set_supported(eqos->phy, eqos->max_speed);
-			if (ret) {
-				pr_err("phy_set_supported() failed: %d", ret);
-				goto err_shutdown_phy;
-			}
-		}
-
-		eqos->phy->node = eqos->phy_of_node;
-		ret = phy_config(eqos->phy);
-		if (ret < 0) {
-			pr_err("phy_config() failed: %d", ret);
-			goto err_shutdown_phy;
-		}
-	}
+	eqos->tx_desc_idx = 0;
+	eqos->rx_desc_idx = 0;
 
 	ret = phy_startup(eqos->phy);
 	if (ret < 0) {
-		pr_err("phy_startup() failed: %d", ret);
+		dev_err(dev, "phy_startup() failed: %d\n", ret);
 		goto err_shutdown_phy;
 	}
 
 	if (!eqos->phy->link) {
-		pr_err("No link");
+		dev_err(dev, "No link\n");
+		ret = -ENOTCONN;
 		goto err_shutdown_phy;
 	}
 
 	ret = eqos_adjust_link(dev);
 	if (ret < 0) {
-		pr_err("eqos_adjust_link() failed: %d", ret);
+		dev_err(dev, "eqos_adjust_link() failed: %d\n", ret);
 		goto err_shutdown_phy;
 	}
 
@@ -1013,9 +974,6 @@ static int eqos_start(struct udevice *dev)
 		rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
 		mb();
 		eqos->config->ops->eqos_flush_desc(rx_desc);
-		eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf +
-						(i * EQOS_MAX_PACKET_SIZE),
-						EQOS_MAX_PACKET_SIZE);
 	}
 
 	writel(0, &eqos->dma_regs->ch0_txdesc_list_haddress);
@@ -1055,10 +1013,8 @@ static int eqos_start(struct udevice *dev)
 
 err_shutdown_phy:
 	phy_shutdown(eqos->phy);
-err_stop_resets:
-	eqos->config->ops->eqos_stop_resets(dev);
 err:
-	pr_err("FAILED: %d", ret);
+	dev_err(dev, "%s() FAILED: %d\n", __func__, ret);
 	return ret;
 }
 
@@ -1072,7 +1028,6 @@ static void eqos_stop(struct udevice *dev)
 	if (!eqos->started)
 		return;
 	eqos->started = false;
-	eqos->reg_access_ok = false;
 
 	/* Disable TX DMA */
 	clrbits_le32(&eqos->dma_regs->ch0_tx_control,
@@ -1110,7 +1065,6 @@ static void eqos_stop(struct udevice *dev)
 	if (eqos->phy) {
 		phy_shutdown(eqos->phy);
 	}
-	eqos->config->ops->eqos_stop_resets(dev);
 
 	debug("%s: OK\n", __func__);
 }
@@ -1160,7 +1114,9 @@ static int eqos_send(struct udevice *dev, void *packet, int length)
 static int eqos_recv(struct udevice *dev, int flags, uchar **packetp)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
+	u32 idx, idx_mask = eqos->desc_per_cacheline - 1;
 	struct eqos_desc *rx_desc;
+	void *dmabuf;
 	int length;
 
 	debug("%s(dev=%p, flags=%x):\n", __func__, dev, flags);
@@ -1171,33 +1127,7 @@ static int eqos_recv(struct udevice *dev, int flags, uchar **packetp)
 		debug("%s: RX packet not available\n", __func__);
 		return -EAGAIN;
 	}
-
-	*packetp = eqos->rx_dma_buf +
-		(eqos->rx_desc_idx * EQOS_MAX_PACKET_SIZE);
+	dmabuf = eqos->rx_dma_buf + eqos->rx_desc_idx * EQOS_MAX_PACKET_SIZE;
 	length = rx_desc->des3 & 0x7fff;
-	debug("%s: *packetp=%p, length=%d\n", __func__, *packetp, length);
-
-	eqos->config->ops->eqos_inval_buffer(*packetp, length);
-
-	return length;
-}
-
-static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
-{
-	struct eqos_priv *eqos = dev_get_priv(dev);
-	uchar *packet_expected;
-	struct eqos_desc *rx_desc;
-
-	debug("%s(packet=%p, length=%d)\n", __func__, packet, length);
-
-	packet_expected = eqos->rx_dma_buf +
-		(eqos->rx_desc_idx * EQOS_MAX_PACKET_SIZE);
-	if (packet != packet_expected) {
-		debug("%s: Unexpected packet (expected %p)\n", __func__,
-		      packet_expected);
-		return -EINVAL;
-	}
-
-	eqos->config->ops->eqos_inval_buffer(packet, length);
 
 	rx_desc = eqos_get_desc(eqos, eqos->rx_desc_idx, true);
@@ -1209,6 +1138,5 @@ static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 	rx_desc->des0 = 0;
 	mb();
 	eqos->config->ops->eqos_flush_desc(rx_desc);
-	eqos->config->ops->eqos_inval_buffer(packet, length);
 	rx_desc->des0 = (u32)(ulong)packet;
 	rx_desc->des1 = 0;
@@ -1229,6 +1157,20 @@ static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 	eqos->rx_desc_idx++;
 	eqos->rx_desc_idx %= EQOS_DESCRIPTORS_RX;
 
+	*packetp = memalign(ARCH_DMA_MINALIGN, length);
+	if (!*packetp)
+		return -ENOMEM;
+
+	eqos->config->ops->eqos_inval_buffer(dmabuf, length);
+	memcpy(*packetp, dmabuf, length);
+
+	return length;
+}
+
+static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
+{
+	debug("%s(packet=%p, length=%d)\n", __func__, packet, length);
+	free(packet);
 	return 0;
 }
 
@@ -1339,7 +1281,7 @@ static int eqos_probe_resources_tegra186(struct udevice *dev)
 
 	ret = reset_get_by_name(dev, "eqos", &eqos->reset_ctl);
 	if (ret) {
-		pr_err("reset_get_by_name(rst) failed: %d", ret);
+		dev_err(dev, "reset_get_by_name(rst) failed: %d\n", ret);
 		return ret;
 	}
 
@@ -1347,38 +1289,40 @@ static int eqos_probe_resources_tegra186(struct udevice *dev)
 				   &eqos->phy_reset_gpio,
 				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
 	if (ret) {
-		pr_err("gpio_request_by_name(phy reset) failed: %d", ret);
+		dev_err(dev, "failed to request phy-reset-gpios: %d\n",
+			ret);
 		goto err_free_reset_eqos;
 	}
+	eqos->phy_reset_duration = 2;
 
 	ret = clk_get_by_name(dev, "slave_bus", &eqos->clk_slave_bus);
 	if (ret) {
-		pr_err("clk_get_by_name(slave_bus) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(slave_bus) failed: %d\n", ret);
 		goto err_free_gpio_phy_reset;
 	}
 
 	ret = clk_get_by_name(dev, "master_bus", &eqos->clk_master_bus);
 	if (ret) {
-		pr_err("clk_get_by_name(master_bus) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(master_bus) failed: %d\n", ret);
 		goto err_free_clk_slave_bus;
 	}
 
 	ret = clk_get_by_name(dev, "rx", &eqos->clk_rx);
 	if (ret) {
-		pr_err("clk_get_by_name(rx) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(rx) failed: %d\n", ret);
 		goto err_free_clk_master_bus;
 	}
 
 	ret = clk_get_by_name(dev, "ptp_ref", &eqos->clk_ptp_ref);
 	if (ret) {
-		pr_err("clk_get_by_name(ptp_ref) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(ptp_ref) failed: %d\n", ret);
 		goto err_free_clk_rx;
 		return ret;
 	}
 
 	ret = clk_get_by_name(dev, "tx", &eqos->clk_tx);
 	if (ret) {
-		pr_err("clk_get_by_name(tx) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(tx) failed: %d\n", ret);
 		goto err_free_clk_ptp_ref;
 	}
 
@@ -1414,48 +1358,86 @@ static int eqos_probe_resources_stm32(struct udevice *dev)
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
 	phy_interface_t interface;
+#if IS_ENABLED(CONFIG_REGMAP)
+	const uint rgmii_mask = BIT(eqos->rgmii_bit);
+	const uint intf_sel_mask = (7 << eqos->intf_sel_bit);
+#endif
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
 	interface = eqos->config->interface(dev);
 
-	if (interface == PHY_INTERFACE_MODE_NONE) {
-		pr_err("Invalid PHY interface\n");
+#if IS_ENABLED(CONFIG_REGMAP)
+	switch (interface) {
+	case PHY_INTERFACE_MODE_MII:
+		regmap_update_bits(eqos->gpr, eqos->gpr_reg,
+				   rgmii_mask | intf_sel_mask, 0);
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		regmap_update_bits(eqos->gpr, eqos->gpr_reg,
+				   rgmii_mask | intf_sel_mask,
+				   4 << eqos->intf_sel_bit);
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+		regmap_update_bits(eqos->gpr, eqos->gpr_reg,
+				   rgmii_mask | intf_sel_mask,
+				   rgmii_mask | (1 << eqos->intf_sel_bit));
+		break;
+	default:
+		dev_err(dev, "Invalid PHY interface '%s'\n",
+			phy_string_for_interface(interface));
 		return -EINVAL;
 	}
-
+#endif
 	ret = board_interface_eth_init(dev, interface);
 	if (ret)
-		return -EINVAL;
+		return ret;
 
 	eqos->max_speed = dev_read_u32_default(dev, "max-speed", 0);
 
 	ret = clk_get_by_name(dev, "stmmaceth", &eqos->clk_master_bus);
 	if (ret) {
-		pr_err("clk_get_by_name(master_bus) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(master_bus) failed: %d\n", ret);
 		goto err_probe;
 	}
 
 	ret = clk_get_by_name(dev, "mac-clk-rx", &eqos->clk_rx);
 	if (ret) {
-		pr_err("clk_get_by_name(rx) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(rx) failed: %d\n", ret);
 		goto err_free_clk_master_bus;
 	}
 
 	ret = clk_get_by_name(dev, "mac-clk-tx", &eqos->clk_tx);
 	if (ret) {
-		pr_err("clk_get_by_name(tx) failed: %d", ret);
+		dev_err(dev, "clk_get_by_name(tx) failed: %d\n", ret);
 		goto err_free_clk_rx;
 	}
 
 	/*  Get ETH_CLK clocks (optional) */
 	ret = clk_get_by_name(dev, "eth-ck", &eqos->clk_ck);
 	if (ret)
-		pr_warn("No phy clock provided %d", ret);
+		dev_warn(dev, "No phy clock provided %d\n", ret);
+
+	ret = gpio_request_by_name(dev, "phy-reset-gpios", 0,
+				   &eqos->phy_reset_gpio,
+				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "requesting phy-reset-gpio failed: %d\n", ret);
+		goto err_free_clk_tx;
+	}
+
+	eqos->phy_reset_duration = dev_read_u32_default(dev,
+							"phy-reset-duration-us",
+							2);
+	eqos->phy_reset_post_delay = dev_read_u32_default(dev,
+							  "phy-reset-post-delay-us",
+							  20000);
 
 	debug("%s: OK\n", __func__);
 	return 0;
 
+err_free_clk_tx:
+	clk_free(&eqos->clk_tx);
 err_free_clk_rx:
 	clk_free(&eqos->clk_rx);
 err_free_clk_master_bus:
@@ -1475,13 +1457,12 @@ static int eqos_remove_resources_tegra186(struct udevice *dev)
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
-#ifdef CONFIG_CLK
 	clk_free(&eqos->clk_tx);
 	clk_free(&eqos->clk_ptp_ref);
 	clk_free(&eqos->clk_rx);
 	clk_free(&eqos->clk_slave_bus);
 	clk_free(&eqos->clk_master_bus);
-#endif
+
 	dm_gpio_free(dev, &eqos->phy_reset_gpio);
 	reset_free(&eqos->reset_ctl);
 
@@ -1495,14 +1476,12 @@ static int eqos_remove_resources_stm32(struct udevice *dev)
 
-#ifdef CONFIG_CLK
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
 	clk_free(&eqos->clk_tx);
 	clk_free(&eqos->clk_rx);
 	clk_free(&eqos->clk_master_bus);
 	if (clk_valid(&eqos->clk_ck))
 		clk_free(&eqos->clk_ck);
-#endif
 
 	if (dm_gpio_is_valid(&eqos->phy_reset_gpio))
 		dm_gpio_free(dev, &eqos->phy_reset_gpio);
@@ -1514,6 +1493,8 @@ static int eqos_probe(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
+	ulong rate;
+	u32 val;
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
@@ -1522,7 +1503,7 @@ static int eqos_probe(struct udevice *dev)
 
 	eqos->regs = dev_read_addr(dev);
 	if (eqos->regs == FDT_ADDR_T_NONE) {
-		pr_err("dev_read_addr() failed");
+		dev_err(dev, "dev_read_addr() failed\n");
 		return -ENODEV;
 	}
 	eqos->mac_regs = (void *)(eqos->regs + EQOS_MAC_REGS_BASE);
@@ -1534,19 +1515,19 @@ static int eqos_probe(struct udevice *dev)
 
 	ret = eqos_probe_resources_core(dev);
 	if (ret < 0) {
-		pr_err("eqos_probe_resources_core() failed: %d", ret);
+		dev_err(dev, "eqos_probe_resources_core() failed: %d\n", ret);
 		return ret;
 	}
 
 	ret = eqos->config->ops->eqos_probe_resources(dev);
 	if (ret < 0) {
-		pr_err("eqos_probe_resources() failed: %d", ret);
+		dev_err(dev, "eqos_probe_resources() failed: %d\n", ret);
 		goto err_remove_resources_core;
 	}
 
 	ret = eqos->config->ops->eqos_start_clks(dev);
 	if (ret < 0) {
-		pr_err("eqos_start_clks() failed: %d", ret);
+		pr_err("eqos_start_clks() failed: %d\n", ret);
 		goto err_remove_resources_tegra;
 	}
 
@@ -1556,7 +1537,7 @@ static int eqos_probe(struct udevice *dev)
 	if (!eqos->mii) {
 		eqos->mii = mdio_alloc();
 		if (!eqos->mii) {
-			pr_err("mdio_alloc() failed");
+			pr_err("mdio_alloc() failed\n");
 			ret = -ENOMEM;
 			goto err_stop_clks;
 		}
@@ -1567,7 +1548,7 @@ static int eqos_probe(struct udevice *dev)
 
 		ret = mdio_register(eqos->mii);
 		if (ret < 0) {
-			pr_err("mdio_register() failed: %d", ret);
+			pr_err("mdio_register() failed: %d\n", ret);
 			goto err_free_mdio;
 		}
 	}
@@ -1575,14 +1556,66 @@ static int eqos_probe(struct udevice *dev)
 #ifdef CONFIG_DM_ETH_PHY
 	eth_phy_set_mdio_bus(dev, eqos->mii);
 #endif
+	ret = eqos->config->ops->eqos_start_clks(dev);
+	if (ret < 0) {
+		dev_err(dev, "eqos_start_clks() failed: %d\n", ret);
+		goto err_unregister_mdio;
+	}
+
+	ret = eqos->config->ops->eqos_start_resets(dev);
+	if (ret < 0) {
+		dev_err(dev, "eqos_start_resets() failed: %d\n", ret);
+		goto err_stop_clks;
+	}
+
+	udelay(10);
+
+	eqos->reg_access_ok = true;
+
+	ret = wait_for_bit_le32(&eqos->dma_regs->mode,
+				EQOS_DMA_MODE_SWR, false,
+				eqos->config->swr_wait, false);
+	if (ret) {
+		dev_err(dev, "EQOS_DMA_MODE_SWR stuck\n");
+		goto err_stop_resets;
+	}
+
+	ret = eqos->config->ops->eqos_calibrate_pads(dev);
+	if (ret < 0) {
+		dev_err(dev, "eqos_calibrate_pads() failed: %d\n", ret);
+		goto err_stop_resets;
+	}
+	rate = eqos->config->ops->eqos_get_tick_clk_rate(dev);
+
+	val = (rate / 1000000) - 1;
+	writel(val, &eqos->mac_regs->us_tic_counter);
+
+	eqos->phy = phy_connect(eqos->mii, eqos->phy_addr, dev,
+				eqos->config->interface(dev));
+	if (!eqos->phy) {
+		dev_err(dev, "phy_connect() failed\n");
+		ret = -EIO;
+		goto err_stop_resets;
+	}
+	ret = phy_config(eqos->phy);
+	if (ret < 0) {
+		dev_err(dev, "phy_config() failed: %d\n", ret);
+		goto err_shutdown_phy;
+	}
 
 	debug("%s: OK\n", __func__);
 	return 0;
 
-err_free_mdio:
-	mdio_free(eqos->mii);
+err_shutdown_phy:
+	phy_shutdown(eqos->phy);
+err_stop_resets:
+	eqos->config->ops->eqos_stop_resets(dev);
 err_stop_clks:
 	eqos->config->ops->eqos_stop_clks(dev);
+err_unregister_mdio:
+	mdio_unregister(eqos->mii);
+err_free_mdio:
+	mdio_free(eqos->mii);
 err_remove_resources_tegra:
 	eqos->config->ops->eqos_remove_resources(dev);
 err_remove_resources_core:
@@ -1598,6 +1631,7 @@ static int eqos_remove(struct udevice *dev)
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
+	eqos->config->ops->eqos_stop_resets(dev);
 	mdio_unregister(eqos->mii);
 	mdio_free(eqos->mii);
 	eqos->config->ops->eqos_stop_clks(dev);
@@ -1621,7 +1655,7 @@ static const struct eth_ops eqos_ops = {
 	.recv = eqos_recv,
 	.free_pkt = eqos_free_pkt,
 	.write_hwaddr = eqos_write_hwaddr,
-	.read_rom_hwaddr	= eqos_read_rom_hwaddr,
+	.read_rom_hwaddr = eqos_read_rom_hwaddr,
 };
 
 static struct eqos_ops eqos_tegra186_ops = {
@@ -1639,6 +1673,6 @@ static struct eqos_ops eqos_tegra186_ops = {
 	.eqos_disable_calibration = eqos_disable_calibration_tegra186,
 	.eqos_set_tx_clk_speed = eqos_set_tx_clk_speed_tegra186,
-	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_tegra186
+	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_tegra186,
 };
 
 static const struct eqos_config __maybe_unused eqos_tegra186_config = {
@@ -1650,7 +1684,7 @@ static const struct eqos_config __maybe_unused eqos_tegra186_config = {
 	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_20_35,
 	.axi_bus_width = EQOS_AXI_WIDTH_128,
 	.interface = eqos_get_interface_tegra186,
-	.ops = &eqos_tegra186_ops
+	.ops = &eqos_tegra186_ops,
 };
 
 static struct eqos_ops eqos_stm32_ops = {
@@ -1660,14 +1694,14 @@ static struct eqos_ops eqos_stm32_ops = {
 	.eqos_flush_buffer = eqos_flush_buffer_generic,
 	.eqos_probe_resources = eqos_probe_resources_stm32,
 	.eqos_remove_resources = eqos_remove_resources_stm32,
-	.eqos_stop_resets = eqos_null_ops,
-	.eqos_start_resets = eqos_null_ops,
+	.eqos_stop_resets = eqos_stop_resets_generic,
+	.eqos_start_resets = eqos_start_resets_generic,
 	.eqos_stop_clks = eqos_stop_clks_stm32,
 	.eqos_start_clks = eqos_start_clks_stm32,
 	.eqos_calibrate_pads = eqos_null_ops,
 	.eqos_disable_calibration = eqos_null_ops,
 	.eqos_set_tx_clk_speed = eqos_null_ops,
-	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_stm32
+	.eqos_get_tick_clk_rate = eqos_get_tick_clk_rate_stm32,
 };
 
 static const struct eqos_config __maybe_unused eqos_stm32_config = {
@@ -1679,6 +1713,6 @@ static const struct eqos_config __maybe_unused eqos_stm32_config = {
 	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_250_300,
 	.axi_bus_width = EQOS_AXI_WIDTH_64,
 	.interface = eqos_get_interface_stm32,
-	.ops = &eqos_stm32_ops
+	.ops = &eqos_stm32_ops,
 };
 
@@ -2162,20 +2169,20 @@
 static const struct udevice_id eqos_ids[] = {
 #if IS_ENABLED(CONFIG_DWC_ETH_QOS_TEGRA186)
 	{
 		.compatible = "nvidia,tegra186-eqos",
-		.data = (ulong)&eqos_tegra186_config
+		.data = (ulong)&eqos_tegra186_config,
 	},
 #endif
 #if IS_ENABLED(CONFIG_DWC_ETH_QOS_STM32)
 	{
 		.compatible = "st,stm32mp1-dwmac",
-		.data = (ulong)&eqos_stm32_config
+		.data = (ulong)&eqos_stm32_config,
 	},
 #endif
 #if IS_ENABLED(CONFIG_DWC_ETH_QOS_IMX)
 	{
 		.compatible = "fsl,imx-eqos",
-		.data = (ulong)&eqos_imx_config
+		.data = (ulong)&eqos_imx_config,
 	},
 #endif
 
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index bbc4434ddb..925efffdbe 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -19,6 +19,7 @@
 #include <netdev.h>
 #include <asm/cache.h>
 #include <asm/global_data.h>
+#include <dm/device_compat.h>
 #include <linux/delay.h>
 #include <power/regulator.h>
 
@@ -74,8 +75,6 @@ DECLARE_GLOBAL_DATA_PTR;
 #error "PKTALIGN must be multiple of ARCH_DMA_MINALIGN!"
 #endif
 
-#undef DEBUG
-
 #ifdef CONFIG_FEC_MXC_SWAP_PACKET
 static void swap_packet(uint32_t *packet, int length)
 {
@@ -827,7 +826,8 @@ static int fecmxc_recv(struct udevice *dev, int flags, uchar **packetp)
 	/* Check if any critical events have happened */
 	ievent = readl(&fec->eth->ievent);
 	writel(ievent, &fec->eth->ievent);
-	debug("fec_recv: ievent 0x%lx\n", ievent);
+	if (ievent)
+		debug("%s: ievent 0x%lx\n", __func__, ievent);
 	if (ievent & FEC_IEVENT_BABR) {
 		fecmxc_halt(dev);
 		fecmxc_init(dev);
@@ -868,9 +868,9 @@ static int fecmxc_recv(struct udevice *dev, int flags, uchar **packetp)
 	invalidate_dcache_range(addr, addr + size);
 
 	bd_status = readw(&rbd->status);
-	debug("fec_recv: status 0x%x\n", bd_status);
 
 	if (!(bd_status & FEC_RBD_EMPTY)) {
+		debug("%s: status 0x%x\n", __func__, bd_status);
 		if ((bd_status & FEC_RBD_LAST) && !(bd_status & FEC_RBD_ERR) &&
 		    ((readw(&rbd->data_length) - 4) > 14)) {
 			/* Get buffer address and size */
@@ -914,8 +914,8 @@ static int fecmxc_recv(struct udevice *dev, int flags, uchar **packetp)
 
 		fec_rx_task_enable(fec);
 		fec->rbd_index = (fec->rbd_index + 1) % FEC_RBD_NUM;
+		debug("%s: stop\n", __func__);
 	}
-	debug("fec_recv: stop\n");
 
 	return len;
 }
@@ -1142,12 +1142,12 @@ static int fecmxc_probe(struct udevice *dev)
 	if (IS_ENABLED(CONFIG_IMX8)) {
 		ret = clk_get_by_name(dev, "ipg", &priv->ipg_clk);
 		if (ret < 0) {
-			debug("Can't get FEC ipg clk: %d\n", ret);
+			dev_err(dev, "Can't get FEC ipg clk: %d\n", ret);
 			return ret;
 		}
 		ret = clk_enable(&priv->ipg_clk);
 		if (ret < 0) {
-			debug("Can't enable FEC ipg clk: %d\n", ret);
+			dev_err(dev, "Can't enable FEC ipg clk: %d\n", ret);
 			return ret;
 		}
 
@@ -1155,34 +1155,44 @@ static int fecmxc_probe(struct udevice *dev)
 	} else if (CONFIG_IS_ENABLED(CLK_CCF)) {
 		ret = clk_get_by_name(dev, "ipg", &priv->ipg_clk);
 		if (ret < 0) {
-			debug("Can't get FEC ipg clk: %d\n", ret);
+			dev_err(dev, "Can't get FEC ipg clk: %d\n", ret);
 			return ret;
 		}
 		ret = clk_enable(&priv->ipg_clk);
-		if(ret)
+		if (ret) {
+			dev_err(dev, "Can't enable FEC ipg clk: %d\n", ret);
 			return ret;
+		}
 
 		ret = clk_get_by_name(dev, "ahb", &priv->ahb_clk);
 		if (ret < 0) {
-			debug("Can't get FEC ahb clk: %d\n", ret);
+			dev_err(dev, "Can't get FEC ahb clk: %d\n", ret);
 			return ret;
 		}
 		ret = clk_enable(&priv->ahb_clk);
-		if (ret)
+		if (ret) {
+			dev_err(dev, "Can't enable FEC ahb clk: %d\n", ret);
 			return ret;
+		}
 
 		ret = clk_get_by_name(dev, "enet_out", &priv->clk_enet_out);
 		if (!ret) {
 			ret = clk_enable(&priv->clk_enet_out);
-			if (ret)
+			if (ret) {
+				dev_err(dev, "Can't enable FEC enet_out clk: %d\n",
+					ret);
 				return ret;
+			}
 		}
 
 		ret = clk_get_by_name(dev, "enet_clk_ref", &priv->clk_ref);
 		if (!ret) {
 			ret = clk_enable(&priv->clk_ref);
-			if (ret)
+			if (ret) {
+				dev_err(dev, "Can't enable FEC ref clk: %d\n",
+					ret);
 				return ret;
+			}
 		}
 
 		ret = clk_get_by_name(dev, "ptp", &priv->clk_ptp);
@@ -1326,9 +1336,10 @@ static int fecmxc_of_to_plat(struct udevice *dev)
 #if CONFIG_IS_ENABLED(DM_GPIO)
 	ret = gpio_request_by_name(dev, "phy-reset-gpios", 0,
 				   &priv->phy_reset_gpio, GPIOD_IS_OUT);
-	if (ret < 0)
+	if (ret == -ENOENT)
 		return 0; /* property is optional, don't return error! */
-
+	if (ret < 0)
+		return ret;
 	priv->reset_delay = dev_read_u32_default(dev, "phy-reset-duration", 1);
 	if (priv->reset_delay > 1000) {
 		printf("FEC MXC: phy reset duration should be <= 1000ms\n");
diff --git a/drivers/net/phy/micrel_ksz90x1.c b/drivers/net/phy/micrel_ksz90x1.c
index e5f578201f..e83a7c7a65 100644
--- a/drivers/net/phy/micrel_ksz90x1.c
+++ b/drivers/net/phy/micrel_ksz90x1.c
@@ -112,15 +112,24 @@ static int ksz90x1_of_config_group(struct phy_device *phydev,
 {
 	struct udevice *dev = phydev->dev;
 	struct phy_driver *drv = phydev->drv;
-	int val[4];
+	int val;
 	int i, changed = 0, offset, max;
 	u16 regval = 0;
 	ofnode node;
+	struct ofnode_phandle_args phandle_args;
+	int ret;
 
 	if (!drv || !drv->writeext)
 		return -EOPNOTSUPP;
 
-	node = phydev->node;
+	/* Try to locate PHY via phandle */
+	ret = dev_read_phandle_with_args(dev, "phy-handle", NULL, 0, 0,
+					 &phandle_args);
+	if (ret == 0) {
+		node = phandle_args.node;
+	} else {
+		node = phydev->node;
+	}
 
 	if (!ofnode_valid(node)) {
 		/* Look for a PHY node under the Ethernet node */
@@ -133,25 +142,26 @@ static int ksz90x1_of_config_group(struct phy_device *phydev,
 	}
 
 	for (i = 0; i < ofcfg->grpsz; i++) {
-		val[i] = ofnode_read_u32_default(node, ofcfg->grp[i].name, ~0);
+		val = ofnode_read_u32_default(node, ofcfg->grp[i].name, ~0);
 		offset = ofcfg->grp[i].off;
-		if (val[i] == -1) {
+		if (val == -1) {
 			/* Default register value for KSZ9021 */
 			regval |= ofcfg->grp[i].dflt << offset;
 		} else {
 			changed = 1;	/* Value was changed in OF */
 			/* Calculate the register value and fix corner cases */
 			max = (1 << ofcfg->grp[i].size) - 1;
-			if (val[i] > ps_to_regval * max) {
+			if (val > ps_to_regval * max)
 				regval |= max << offset;
-			} else {
-				regval |= (val[i] / ps_to_regval) << offset;
-			}
+			else
+				regval |= (val / ps_to_regval) << offset;
 		}
 	}
 
 	if (!changed)
 		return 0;
+	debug("%s@%d: Writing %04x to %02x\n", __func__, __LINE__,
+	      regval, ofcfg->reg);
 
 	return drv->writeext(phydev, 0, ofcfg->devad, ofcfg->reg, regval);
 }
@@ -349,6 +359,7 @@ static int ksz9031_phy_extwrite(struct phy_device *phydev, int addr,
 static int ksz9031_config(struct phy_device *phydev)
 {
 	int ret;
+	unsigned int features = phydev->drv->features;
 
 	ret = ksz9031_of_config(phydev);
 	if (ret)
@@ -359,11 +370,9 @@ static int ksz9031_config(struct phy_device *phydev)
 
 	/* add an option to disable the gigabit feature of this PHY */
 	if (env_get("disable_giga")) {
-		unsigned features;
 		unsigned bmcr;
 
 		/* disable speed 1000 in features supported by the PHY */
-		features = phydev->drv->features;
 		features &= ~(SUPPORTED_1000baseT_Half |
 				SUPPORTED_1000baseT_Full);
 		phydev->advertising = phydev->supported = features;
@@ -381,6 +390,18 @@ static int ksz9031_config(struct phy_device *phydev)
 		genphy_restart_aneg(phydev);
 
 		return 0;
+	} else {
+		/* force master mode for 1000BaseT due to chip errata */
+		uint16_t ctrl1000 = 0;
+		const uint16_t master = CTRL1000_PREFER_MASTER |
+			CTRL1000_CONFIG_MASTER | CTRL1000_MANUAL_CONFIG;
+
+		if (features & SUPPORTED_1000baseT_Half)
+			ctrl1000 |= ADVERTISE_1000HALF | master;
+		if (features & SUPPORTED_1000baseT_Full)
+			ctrl1000 |= ADVERTISE_1000FULL | master;
+
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_CTRL1000, ctrl1000);
 	}
 
 	return genphy_config(phydev);
diff --git a/drivers/pinctrl/pinctrl-uclass.c b/drivers/pinctrl/pinctrl-uclass.c
index ce2d5ddf6d..3e041f4d03 100644
--- a/drivers/pinctrl/pinctrl-uclass.c
+++ b/drivers/pinctrl/pinctrl-uclass.c
@@ -411,7 +411,7 @@ static int __maybe_unused pinctrl_post_bind(struct udevice *dev)
 	dev_or_flags(dev, DM_FLAG_PROBE_AFTER_BIND);
 
 	if (!ops) {
-		dev_dbg(dev, "ops is not set.  Do not bind.\n");
+		dev_err(dev, "ops is not set.  Do not bind.\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/serial/serial_mxc.c b/drivers/serial/serial_mxc.c
index 82c0d84628..be605b42f2 100644
--- a/drivers/serial/serial_mxc.c
+++ b/drivers/serial/serial_mxc.c
@@ -4,15 +4,19 @@
  */
 
 #include <common.h>
+#include <clk.h>
+#include <debug_uart.h>
 #include <dm.h>
 #include <errno.h>
 #include <watchdog.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/clock.h>
 #include <asm/global_data.h>
+#include <dm/device_compat.h>
 #include <dm/platform_data/serial_mxc.h>
 #include <serial.h>
 #include <linux/compiler.h>
+#include <linux/delay.h>
 
 /* UART Control Register Bit Fields.*/
 #define URXD_CHARRDY	(1<<15)
@@ -144,8 +148,22 @@ struct mxc_uart {
 	u32 ts;
 };
 
+static void _mxc_serial_flush(struct mxc_uart *base)
+{
+	unsigned int timeout = 4000;
+
+	if (!(readl(&base->cr1) & UCR1_UARTEN) ||
+	    !(readl(&base->cr2) & UCR2_TXEN))
+		return;
+
+	while (!(readl(&base->sr2) & USR2_TXDC) && --timeout)
+		udelay(1);
+}
+
 static void _mxc_serial_init(struct mxc_uart *base, int use_dte)
 {
+	_mxc_serial_flush(base);
+
 	writel(0, &base->cr1);
 	writel(0, &base->cr2);
 
@@ -169,6 +187,8 @@ static void _mxc_serial_setbrg(struct mxc_uart *base, unsigned long clk,
 {
 	u32 tmp;
 
+	_mxc_serial_flush(base);
+
 	tmp = RFDIV << UFCR_RFDIV_SHF;
 	if (use_dte)
 		tmp |= UFCR_DCEDTE;
@@ -192,6 +212,39 @@ static void _mxc_serial_setbrg(struct mxc_uart *base, unsigned long clk,
 	writel(UCR1_UARTEN, &base->cr1);
 }
 
+#ifdef CONFIG_DEBUG_UART_MXC
+static int init_needed = 1;
+
+static inline void _debug_uart_init(void)
+{
+	struct mxc_uart *base = (struct mxc_uart *)CONFIG_VAL(DEBUG_UART_BASE);
+
+	if (init_needed) {
+		_mxc_serial_init(base, false);
+		_mxc_serial_setbrg(base, CONFIG_DEBUG_UART_CLOCK,
+				   CONFIG_BAUDRATE, false);
+
+		init_needed = 0;
+	}
+}
+
+static inline void _debug_uart_putc(int ch)
+{
+	struct mxc_uart *base = (struct mxc_uart *)CONFIG_VAL(DEBUG_UART_BASE);
+
+	if (init_needed)
+		return;
+
+	while ((readl(&base->ts) & UTS_TXFULL))
+		schedule();
+
+	writel(ch, &base->txd);
+}
+
+DEBUG_UART_FUNCS
+
+#endif
+
 #if !CONFIG_IS_ENABLED(DM_SERIAL)
 
 #ifndef CONFIG_MXC_UART_BASE
@@ -223,11 +276,11 @@ static void mxc_serial_putc(const char c)
 	if (c == '\n')
 		serial_putc('\r');
 
-	writel(c, &mxc_base->txd);
-
 	/* wait for transmitter to be ready */
-	while (!(readl(&mxc_base->ts) & UTS_TXEMPTY))
+	while ((readl(&mxc_base->ts) & UTS_TXFULL))
 		WATCHDOG_RESET();
+
+	writel(c, &mxc_base->txd);
 }
 
 /* Test whether a character is in the RX buffer */
@@ -252,10 +305,17 @@ static int mxc_serial_init(void)
 	return 0;
 }
 
+static int mxc_serial_stop(void)
+{
+	_mxc_serial_flush(mxc_base);
+
+	return 0;
+}
+
 static struct serial_device mxc_serial_drv = {
 	.name	= "mxc_serial",
 	.start	= mxc_serial_init,
-	.stop	= NULL,
+	.stop	= mxc_serial_stop,
 	.setbrg	= mxc_serial_setbrg,
 	.putc	= mxc_serial_putc,
 	.puts	= default_serial_puts,
@@ -289,7 +349,36 @@ int mxc_serial_setbrg(struct udevice *dev, int baudrate)
 static int mxc_serial_probe(struct udevice *dev)
 {
 	struct mxc_serial_plat *plat = dev_get_plat(dev);
-
+#if CONFIG_IS_ENABLED(CLK_CCF)
+	struct clk *reg_clk = devm_clk_get(dev, "ipg");
+	int ret;
+
+	if (IS_ERR(reg_clk)) {
+		ret = PTR_ERR(reg_clk);
+		if (IS_ENABLED(CONFIG_DEBUG_UART)) {
+			debug_uart_init();
+			printascii("Failed to get register clock: -");
+			printdec(-ret);
+			printch('\n');
+		}
+		dev_err(dev, "Failed to get register clock: %d\n", ret);
+		return ret;
+	}
+	ret = clk_enable(reg_clk);
+	if (ret) {
+		if (IS_ENABLED(CONFIG_DEBUG_UART)) {
+			debug_uart_init();
+			printascii("Failed to enable register clock: -");
+			printdec(-ret);
+			printch('\n');
+		}
+		dev_err(dev, "%s@%d: Failed to enable register clock: %d\n",
+			__func__, __LINE__, ret);
+		return ret;
+	}
+#else
+	debug("%s@%d: No clk support\n", __func__, __LINE__);
+#endif
 	_mxc_serial_init(plat->reg, plat->use_dte);
 
 	return 0;
@@ -311,7 +400,7 @@ static int mxc_serial_putc(struct udevice *dev, const char ch)
 	struct mxc_serial_plat *plat = dev_get_plat(dev);
 	struct mxc_uart *const uart = plat->reg;
 
-	if (!(readl(&uart->ts) & UTS_TXEMPTY))
+	if ((readl(&uart->ts) & UTS_TXFULL))
 		return -EAGAIN;
 
 	writel(ch, &uart->txd);
@@ -380,28 +469,3 @@ U_BOOT_DRIVER(serial_mxc) = {
 };
 #endif
 
-#ifdef CONFIG_DEBUG_UART_MXC
-#include <debug_uart.h>
-
-static inline void _debug_uart_init(void)
-{
-	struct mxc_uart *base = (struct mxc_uart *)CONFIG_VAL(DEBUG_UART_BASE);
-
-	_mxc_serial_init(base, false);
-	_mxc_serial_setbrg(base, CONFIG_DEBUG_UART_CLOCK,
-			   CONFIG_BAUDRATE, false);
-}
-
-static inline void _debug_uart_putc(int ch)
-{
-	struct mxc_uart *base = (struct mxc_uart *)CONFIG_VAL(DEBUG_UART_BASE);
-
-	while (!(readl(&base->ts) & UTS_TXEMPTY))
-		WATCHDOG_RESET();
-
-	writel(ch, &base->txd);
-}
-
-DEBUG_UART_FUNCS
-
-#endif
diff --git a/drivers/timer/mpc83xx_timer.c b/drivers/timer/mpc83xx_timer.c
index 410bf723d6..588f6e663a 100644
--- a/drivers/timer/mpc83xx_timer.c
+++ b/drivers/timer/mpc83xx_timer.c
@@ -182,6 +182,10 @@ void timer_interrupt(struct pt_regs *regs)
 #ifdef CONFIG_LED_STATUS
 	status_led_tick(priv->timestamp);
 #endif /* CONFIG_LED_STATUS */
+
+#ifdef CONFIG_SHOW_ACTIVITY
+	board_show_activity(priv->timestamp);
+#endif /* CONFIG_SHOW_ACTIVITY */
 }
 
 void wait_ticks(ulong ticks)
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 532746dd88..5dcf217e1d 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -99,20 +99,20 @@
 #define DWC3_GPRTBIMAP_FS0	0xc188
 #define DWC3_GPRTBIMAP_FS1	0xc18c
 
-#define DWC3_GUSB2PHYCFG(n)	(0xc200 + (n * 0x04))
-#define DWC3_GUSB2I2CCTL(n)	(0xc240 + (n * 0x04))
+#define DWC3_GUSB2PHYCFG(n)	(0xc200 + ((n) * 0x04))
+#define DWC3_GUSB2I2CCTL(n)	(0xc240 + ((n) * 0x04))
 
-#define DWC3_GUSB2PHYACC(n)	(0xc280 + (n * 0x04))
+#define DWC3_GUSB2PHYACC(n)	(0xc280 + ((n) * 0x04))
 
-#define DWC3_GUSB3PIPECTL(n)	(0xc2c0 + (n * 0x04))
+#define DWC3_GUSB3PIPECTL(n)	(0xc2c0 + ((n) * 0x04))
 
-#define DWC3_GTXFIFOSIZ(n)	(0xc300 + (n * 0x04))
-#define DWC3_GRXFIFOSIZ(n)	(0xc380 + (n * 0x04))
+#define DWC3_GTXFIFOSIZ(n)	(0xc300 + ((n) * 0x04))
+#define DWC3_GRXFIFOSIZ(n)	(0xc380 + ((n) * 0x04))
 
-#define DWC3_GEVNTADRLO(n)	(0xc400 + (n * 0x10))
-#define DWC3_GEVNTADRHI(n)	(0xc404 + (n * 0x10))
-#define DWC3_GEVNTSIZ(n)	(0xc408 + (n * 0x10))
-#define DWC3_GEVNTCOUNT(n)	(0xc40c + (n * 0x10))
+#define DWC3_GEVNTADRLO(n)	(0xc400 + ((n) * 0x10))
+#define DWC3_GEVNTADRHI(n)	(0xc404 + ((n) * 0x10))
+#define DWC3_GEVNTSIZ(n)	(0xc408 + ((n) * 0x10))
+#define DWC3_GEVNTCOUNT(n)	(0xc40c + ((n) * 0x10))
 
 #define DWC3_GHWPARAMS8		0xc600
 #define DWC3_GFLADJ		0xc630
@@ -125,10 +125,10 @@
 #define DWC3_DGCMDPAR		0xc710
 #define DWC3_DGCMD		0xc714
 #define DWC3_DALEPENA		0xc720
-#define DWC3_DEPCMDPAR2(n)	(0xc800 + (n * 0x10))
-#define DWC3_DEPCMDPAR1(n)	(0xc804 + (n * 0x10))
-#define DWC3_DEPCMDPAR0(n)	(0xc808 + (n * 0x10))
-#define DWC3_DEPCMD(n)		(0xc80c + (n * 0x10))
+#define DWC3_DEPCMDPAR2(n)	(0xc800 + ((n) * 0x10))
+#define DWC3_DEPCMDPAR1(n)	(0xc804 + ((n) * 0x10))
+#define DWC3_DEPCMDPAR0(n)	(0xc808 + ((n) * 0x10))
+#define DWC3_DEPCMD(n)		(0xc80c + ((n) * 0x10))
 
 /* OTG Registers */
 #define DWC3_OCFG		0xcc00
@@ -406,7 +406,7 @@
 #define DWC3_DEPCMD_SETEPCONFIG		(0x01 << 0)
 
 /* The EP number goes 0..31 so ep0 is always out and ep1 is always in */
-#define DWC3_DALEPENA_EP(n)		(1 << n)
+#define DWC3_DALEPENA_EP(n)		(1 << (n))
 
 #define DWC3_DEPCMD_TYPE_CONTROL	0
 #define DWC3_DEPCMD_TYPE_ISOC		1
@@ -628,9 +628,9 @@ struct dwc3_hwparams {
 #define DWC3_NUM_IN_EPS_MASK	(0x1f << 18)
 #define DWC3_NUM_EPS_MASK	(0x3f << 12)
 #define DWC3_NUM_EPS(p)		(((p)->hwparams3 &		\
-			(DWC3_NUM_EPS_MASK)) >> 12)
+			DWC3_NUM_EPS_MASK) >> 12)
 #define DWC3_NUM_IN_EPS(p)	(((p)->hwparams3 &		\
-			(DWC3_NUM_IN_EPS_MASK)) >> 18)
+			DWC3_NUM_IN_EPS_MASK) >> 18)
 
 /* HWPARAMS7 */
 #define DWC3_RAM1_DEPTH(n)	((n) & 0xffff)
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index eb416b832a..62493d0039 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -1128,8 +1128,8 @@ static int dwc3_gadget_ep_dequeue(struct usb_ep *ep,
 			dwc3_stop_active_transfer(dwc, dep->number, true);
 			goto out1;
 		}
-		dev_err(dwc->dev, "request %p was not queued to %s\n",
-				request, ep->name);
+		dev_dbg(dwc->dev, "request %p was not queued to %s\n",
+			request, ep->name);
 		ret = -EINVAL;
 		goto out0;
 	}
@@ -1764,7 +1764,7 @@ static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,
 	req = next_request(&dep->req_queued);
 	if (!req) {
 		WARN_ON_ONCE(1);
-		return 1;
+		return 0;
 	}
 
 	slot = req->start_slot;
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index e8da73c788..eaca71e091 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -147,6 +147,7 @@ config USB_GADGET_VBUS_DRAW
 
 config SDP_LOADADDR
 	hex "Default load address at SDP_WRITE and SDP_JUMP"
+	depends on SPL_USB_SDP_SUPPORT || USB_FUNCTION_SDP
 	default 0
 
 # Selected by UDC drivers that support high-speed operation.
diff --git a/drivers/usb/gadget/f_fastboot.c b/drivers/usb/gadget/f_fastboot.c
index 07b1681c8a..02fc9ac99d 100644
--- a/drivers/usb/gadget/f_fastboot.c
+++ b/drivers/usb/gadget/f_fastboot.c
@@ -487,6 +487,10 @@ static void rx_handler_dl_image(struct usb_ep *ep, struct usb_request *req)
 static void do_exit_on_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	g_dnl_trigger_detach();
+	if (env_get(".bootcmd")) {
+		env_set("bootcmd", env_get(".bootcmd"));
+		env_set(".bootcmd", NULL);
+	}
 }
 
 static void do_bootm_on_complete(struct usb_ep *ep, struct usb_request *req)
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 45f0504b6e..edc0bcbfc6 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -246,6 +246,7 @@
 #include <common.h>
 #include <console.h>
 #include <g_dnl.h>
+#include <watchdog.h>
 #include <dm/devres.h>
 #include <linux/bug.h>
 
@@ -673,6 +674,8 @@ static int sleep_thread(struct fsg_common *common)
 			if (ctrlc())
 				return -EPIPE;
 
+			WATCHDOG_RESET();
+
 			/* Check cable connection */
 			if (!g_dnl_board_usb_cable_connected())
 				return -EIO;
diff --git a/drivers/usb/gadget/f_sdp.c b/drivers/usb/gadget/f_sdp.c
index af4b167e17..fc686bbd71 100644
--- a/drivers/usb/gadget/f_sdp.c
+++ b/drivers/usb/gadget/f_sdp.c
@@ -318,8 +318,8 @@ static void sdp_rx_command_complete(struct usb_ep *ep, struct usb_request *req)
 		sdp->dnl_address = be32_to_cpu(cmd->addr);
 		sdp->dnl_bytes_remaining = be32_to_cpu(cmd->cnt);
 		sdp->next_state = SDP_STATE_TX_REGISTER;
-		printf("Reading %d registers at 0x%08x... ",
-		       sdp->dnl_bytes_remaining, sdp->dnl_address);
+		debug("Reading %d registers at 0x%08x... ",
+		      sdp->dnl_bytes_remaining, sdp->dnl_address);
 		break;
 	case SDP_WRITE_FILE:
 		sdp->always_send_status = true;
@@ -331,8 +331,8 @@ static void sdp_rx_command_complete(struct usb_ep *ep, struct usb_request *req)
 		sdp->dnl_bytes = sdp->dnl_bytes_remaining;
 		sdp->next_state = SDP_STATE_IDLE;
 
-		printf("Downloading file of size %d to 0x%08x... ",
-		       sdp->dnl_bytes_remaining, sdp->dnl_address);
+		debug("Downloading file of size %d to 0x%08x... ",
+		      sdp->dnl_bytes_remaining, sdp->dnl_address);
 
 		break;
 	case SDP_ERROR_STATUS:
@@ -413,7 +413,7 @@ static void sdp_rx_data_complete(struct usb_ep *ep, struct usb_request *req)
 #ifndef CONFIG_SPL_BUILD
 	env_set_hex("filesize", sdp->dnl_bytes);
 #endif
-	printf("done\n");
+	debug("done\n");
 
 	switch (sdp->state) {
 	case SDP_STATE_RX_FILE_DATA_BUSY:
@@ -704,7 +704,7 @@ static int sdp_bind_config(struct usb_configuration *c)
 
 int sdp_init(int controller_index)
 {
-	printf("SDP: initialize...\n");
+	debug("SDP: initialize...\n");
 	while (!sdp_func->configuration_done) {
 		if (ctrlc()) {
 			puts("\rCTRL+C - Operation aborted.\n");
@@ -724,11 +724,11 @@ static u32 sdp_jump_imxheader(void *address)
 	ulong (*entry)(void);
 
 	if (headerv2->header.tag != IVT_HEADER_TAG) {
-		printf("Header Tag is not an IMX image\n");
+		debug("Header Tag is not an IMX image\n");
 		return SDP_ERROR_IMXHEADER;
 	}
 
-	printf("Jumping to 0x%08x\n", headerv2->entry);
+	debug("Jumping to 0x%08x\n", headerv2->entry);
 	entry = sdp_ptr(headerv2->entry);
 	entry();
 
@@ -820,7 +820,7 @@ static int sdp_handle_in_ep(struct spl_image_info *spl_image,
 		sdp_func->state = SDP_STATE_TX_REGISTER_BUSY;
 		break;
 	case SDP_STATE_JUMP:
-		printf("Jumping to header at 0x%08x\n", sdp_func->jmp_address);
+		debug("Jumping to header at 0x%08x\n", sdp_func->jmp_address);
 		status = sdp_jump_imxheader(sdp_ptr(sdp_func->jmp_address));
 
 		/* If imx header fails, try some U-Boot specific headers */
@@ -833,7 +833,7 @@ static int sdp_handle_in_ep(struct spl_image_info *spl_image,
 			if (sdp_func->jmp_address == 0)
 				panic("Error in search header, failed to jump\n");
 
-			printf("Found header at 0x%08x\n", sdp_func->jmp_address);
+			debug("Found header at 0x%08x\n", sdp_func->jmp_address);
 
 			struct legacy_img_hdr *header =
 				sdp_ptr(sdp_func->jmp_address);
diff --git a/drivers/usb/host/usb-uclass.c b/drivers/usb/host/usb-uclass.c
index 060f3441df..55296055a4 100644
--- a/drivers/usb/host/usb-uclass.c
+++ b/drivers/usb/host/usb-uclass.c
@@ -397,8 +397,8 @@ int usb_setup_ehci_gadget(struct ehci_ctrl **ctlrp)
 
 	/* Find the old device and remove it */
 	ret = uclass_find_first_device(UCLASS_USB, &dev);
-	if (ret)
-		return ret;
+	if (ret || !dev)
+		return ret ?: -ENODEV;
 	ret = device_remove(dev, DM_REMOVE_NORMAL);
 	if (ret)
 		return ret;
@@ -420,8 +420,8 @@ int usb_remove_ehci_gadget(struct ehci_ctrl **ctlrp)
 
 	/* Find the old device and remove it */
 	ret = uclass_find_first_device(UCLASS_USB, &dev);
-	if (ret)
-		return ret;
+	if (ret || !dev)
+		return ret ?: -ENODEV;
 	ret = device_remove(dev, DM_REMOVE_NORMAL);
 	if (ret)
 		return ret;
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index f1b1cf63ca..c9bf1c67fc 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -354,6 +354,7 @@ config WDT_TANGIER
 config SPL_WDT
 	bool "Enable driver model for watchdog timer drivers in SPL"
 	depends on SPL_DM
+	imply SPL_WATCHDOG
 	help
 	  Enable driver model for watchdog timer in SPL.
 	  This is similar to CONFIG_WDT in U-Boot.
diff --git a/env/Kconfig b/env/Kconfig
index 24111dfaf4..eed6354d75 100644
--- a/env/Kconfig
+++ b/env/Kconfig
@@ -61,6 +61,12 @@ config ENV_IS_NOWHERE
 	  stored. U-Boot will therefore always start up with a default
 	  environment.
 
+config UBOOT_IGNORE_ENV
+       bool
+       help
+	 Ignore non-volatile environment settings and use default
+	 environment only.
+
 config ENV_IS_IN_EEPROM
 	bool "Environment in EEPROM"
 	depends on !CHAIN_OF_TRUST
diff --git a/env/callback.c b/env/callback.c
index 638a02b28f..509f2c2d41 100644
--- a/env/callback.c
+++ b/env/callback.c
@@ -7,6 +7,7 @@
 #include <common.h>
 #include <env.h>
 #include <env_internal.h>
+#include <malloc.h>
 #include <asm/global_data.h>
 
 #if defined(CONFIG_NEEDS_MANUAL_RELOC)
@@ -37,7 +38,7 @@ static struct env_clbk_tbl *find_env_callback(const char *name)
 }
 
 static int first_call = 1;
-static const char *callback_list;
+static char *callback_list;
 
 /*
  * Look for a possible callback for a newly added variable
@@ -52,7 +53,7 @@ void env_callback_init(struct env_entry *var_entry)
 	int ret = 1;
 
 	if (first_call) {
-		callback_list = env_get(ENV_CALLBACK_VAR);
+		callback_list = strdup(env_get(ENV_CALLBACK_VAR));
 		first_call = 0;
 	}
 
@@ -105,10 +106,10 @@ static int set_callback(const char *name, const char *value, void *priv)
 
 	/* does the env variable actually exist? */
 	if (ep != NULL) {
-		/* the assocaition delares no callback, so remove the pointer */
-		if (value == NULL || strlen(value) == 0)
+		/* the association declares no callback, so remove the pointer */
+		if (value == NULL || strlen(value) == 0) {
 			ep->callback = NULL;
-		else {
+		} else {
 			/* assign the requested callback */
 			clbkp = find_env_callback(value);
 			if (clbkp != NULL)
@@ -134,6 +135,9 @@ static int on_callbacks(const char *name, const char *value, enum env_op op,
 	/* configure any dynamic callback bindings */
 	env_attr_walk(value, set_callback, NULL);
 
+	free(callback_list);
+	callback_list = strdup(value);
+
 	return 0;
 }
 U_BOOT_ENV_CALLBACK(callbacks, on_callbacks);
diff --git a/fs/fs.c b/fs/fs.c
index 8324b4a22f..545d31c119 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -542,32 +542,15 @@ int fs_size(const char *filename, loff_t *size)
 
 #ifdef CONFIG_LMB
 /* Check if a file may be read to the given address */
-static int fs_read_lmb_check(const char *filename, ulong addr, loff_t offset,
-			     loff_t len, struct fstype_info *info)
+static int fs_read_lmb_check(const char *filename, ulong addr, loff_t len,
+			     struct fstype_info *info)
 {
 	struct lmb lmb;
-	int ret;
-	loff_t size;
-	loff_t read_len;
-
-	/* get the actual size of the file */
-	ret = info->size(filename, &size);
-	if (ret)
-		return ret;
-	if (offset >= size) {
-		/* offset >= EOF, no bytes will be written */
-		return 0;
-	}
-	read_len = size - offset;
-
-	/* limit to 'len' if it is smaller */
-	if (len && len < read_len)
-		read_len = len;
 
 	lmb_init_and_reserve(&lmb, gd->bd, (void *)gd->fdt_blob);
 	lmb_dump_all(&lmb);
 
-	if (lmb_alloc_addr(&lmb, addr, read_len) == addr)
+	if (lmb_alloc_addr(&lmb, addr, len) == addr)
 		return 0;
 
 	log_err("** Reading file would overwrite reserved memory **\n");
@@ -575,16 +558,34 @@ static int fs_read_lmb_check(const char *filename, ulong addr, loff_t offset,
 }
 #endif
 
-static int _fs_read(const char *filename, ulong addr, loff_t offset, loff_t len,
-		    int do_lmb_check, loff_t *actread)
+static int _fs_read(const char *filename, ulong addr, loff_t offset,
+		    loff_t maxlen, int do_lmb_check, loff_t *actread)
 {
 	struct fstype_info *info = fs_get_info(fs_type);
 	void *buf;
 	int ret;
+	loff_t size;
+
+	ret = info->size(filename, &size);
+	if (ret) {
+		printf("Failed to determine size of file %s: %d\n",
+		       filename, ret);
+		goto err;
+	}
+	if (offset >= size)
+		return 0;
+
+	if (maxlen == 0) {
+		maxlen = size - offset;
+	} else if (size - offset > maxlen) {
+		printf("** File %s larger than buffer size; truncating to %llu of %llu bytes\n",
+		       filename, maxlen, size);
+		maxlen = size - offset;
+	}
 
 #ifdef CONFIG_LMB
 	if (do_lmb_check) {
-		ret = fs_read_lmb_check(filename, addr, offset, len, info);
+		ret = fs_read_lmb_check(filename, addr, maxlen, info);
 		if (ret)
 			return ret;
 	}
@@ -594,13 +595,10 @@ static int _fs_read(const char *filename, ulong addr, loff_t offset, loff_t len,
 	 * We don't actually know how many bytes are being read, since len==0
 	 * means read the whole file.
 	 */
-	buf = map_sysmem(addr, len);
-	ret = info->read(filename, buf, offset, len, actread);
+	buf = map_sysmem(addr, maxlen);
+	ret = info->read(filename, buf, offset, maxlen, actread);
 	unmap_sysmem(buf);
-
-	/* If we requested a specific number of bytes, check we got it */
-	if (ret == 0 && len && *actread != len)
-		log_debug("** %s shorter than offset + len **\n", filename);
+ err:
 	fs_close();
 
 	return ret;
@@ -735,14 +733,14 @@ int do_size(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], fstype))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (fs_size(argv[3], &size) < 0)
 		return CMD_RET_FAILURE;
 
 	env_set_hex("filesize", size);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_load(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
@@ -765,7 +763,7 @@ int do_load(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 
 	if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, fstype)) {
 		log_err("Can't set block device\n");
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (argc >= 4) {
@@ -785,7 +783,7 @@ int do_load(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		filename = env_get("bootfile");
 		if (!filename) {
 			puts("** No boot file defined **\n");
-			return 1;
+			return CMD_RET_FAILURE;
 		}
 	}
 	if (argc >= 6)
@@ -802,7 +800,7 @@ int do_load(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 	time = get_timer(time);
 	if (ret < 0) {
 		log_err("Failed to load '%s'\n", filename);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
 	if (IS_ENABLED(CONFIG_CMD_BOOTEFI))
@@ -821,7 +819,7 @@ int do_load(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 	env_set_hex("fileaddr", addr);
 	env_set_hex("filesize", len_read);
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_ls(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
@@ -833,12 +831,12 @@ int do_ls(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], (argc >= 3) ? argv[2] : NULL, fstype))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (fs_ls(argc >= 4 ? argv[3] : "/"))
-		return 1;
+		return CMD_RET_FAILURE;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int file_exists(const char *dev_type, const char *dev_part, const char *file,
@@ -865,7 +863,7 @@ int do_save(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], fstype))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	addr = hextoul(argv[3], NULL);
 	filename = argv[4];
@@ -879,7 +877,7 @@ int do_save(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 	ret = fs_write(filename, addr, pos, bytes, &len);
 	time = get_timer(time);
 	if (ret < 0)
-		return 1;
+		return CMD_RET_FAILURE;
 
 	printf("%llu bytes written in %lu ms", len, time);
 	if (time > 0) {
@@ -889,7 +887,7 @@ int do_save(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 	}
 	puts("\n");
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_fs_uuid(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
@@ -903,7 +901,7 @@ int do_fs_uuid(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], fstype))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = fs_uuid(uuid);
 	if (ret)
@@ -925,7 +923,7 @@ int do_fs_type(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], FS_TYPE_ANY))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	info = fs_get_info(fs_type);
 
@@ -946,12 +944,12 @@ int do_rm(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], fstype))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (fs_unlink(argv[3]))
-		return 1;
+		return CMD_RET_FAILURE;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_mkdir(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
@@ -963,15 +961,15 @@ int do_mkdir(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], fstype))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	ret = fs_mkdir(argv[3]);
 	if (ret) {
 		log_err("** Unable to create a directory \"%s\" **\n", argv[3]);
-		return 1;
+		return CMD_RET_FAILURE;
 	}
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_ln(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
@@ -981,12 +979,12 @@ int do_ln(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		return CMD_RET_USAGE;
 
 	if (fs_set_blk_dev(argv[1], argv[2], fstype))
-		return 1;
+		return CMD_RET_FAILURE;
 
 	if (fs_ln(argv[3], argv[4]))
-		return 1;
+		return CMD_RET_FAILURE;
 
-	return 0;
+	return CMD_RET_SUCCESS;
 }
 
 int do_fs_types(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
diff --git a/include/common.h b/include/common.h
index 25c317f443..c0740e001e 100644
--- a/include/common.h
+++ b/include/common.h
@@ -24,6 +24,9 @@
 #include <linux/kernel.h>
 #include <asm/u-boot.h> /* boot information for Linux kernel */
 #include <vsprintf.h>
+#ifdef CONFIG_SHOW_ACTIVITY
+void show_activity(int arg);
+#endif
 #endif	/* __ASSEMBLY__ */
 
 /* Pull in stuff for the build system */
diff --git a/include/cramfs/cramfs_fs.h b/include/cramfs/cramfs_fs.h
index e0c14f04af..e72ef5f742 100644
--- a/include/cramfs/cramfs_fs.h
+++ b/include/cramfs/cramfs_fs.h
@@ -97,4 +97,9 @@ int cramfs_uncompress_block(void *dst, void *src, int srclen);
 int cramfs_uncompress_init(void);
 int cramfs_uncompress_exit(void);
 
+int cramfs_check(struct part_info *info);
+int cramfs_load(char *loadoffset, struct part_info *info, char *filename);
+int cramfs_ls(struct part_info *info, char *filename);
+int cramfs_info(struct part_info *info);
+
 #endif	/* __CRAMFS_H */
diff --git a/include/dm/device_compat.h b/include/dm/device_compat.h
index 82d7a7d492..3d13d64b96 100644
--- a/include/dm/device_compat.h
+++ b/include/dm/device_compat.h
@@ -12,6 +12,7 @@
 #define _DM_DEVICE_COMPAT_H
 
 #include <log.h>
+#include <dm/read.h>
 #include <linux/build_bug.h>
 #include <linux/compat.h>
 
diff --git a/include/dm/pinctrl.h b/include/dm/pinctrl.h
index e3e50afeaf..4e7ba93f30 100644
--- a/include/dm/pinctrl.h
+++ b/include/dm/pinctrl.h
@@ -6,6 +6,8 @@
 #ifndef __PINCTRL_H
 #define __PINCTRL_H
 
+#include <linux/err.h>
+
 #define PINNAME_SIZE	10
 #define PINMUX_SIZE	80
 
diff --git a/include/env_callback.h b/include/env_callback.h
index 85e7fe25f8..f4a0719e07 100644
--- a/include/env_callback.h
+++ b/include/env_callback.h
@@ -38,7 +38,6 @@
 
 #ifdef CONFIG_NET
 #define NET_CALLBACKS \
-	"bootfile:bootfile," \
 	"ipaddr:ipaddr," \
 	"gatewayip:gatewayip," \
 	"netmask:netmask," \
diff --git a/include/fsl_wdog.h b/include/fsl_wdog.h
index 29f00d3b9f..e3c38c0f5c 100644
--- a/include/fsl_wdog.h
+++ b/include/fsl_wdog.h
@@ -2,6 +2,7 @@
 /*
  * (C) Copyright 2015 Freescale Semiconductor, Inc.
  */
+#include <linux/bitops.h>
 
 struct watchdog_regs {
 	u16	wcr;	/* Control */
@@ -9,11 +10,14 @@ struct watchdog_regs {
 	u16	wrsr;	/* Reset Status */
 };
 
-#define WCR_WDZST	0x01
-#define WCR_WDBG	0x02
-#define WCR_WDE		0x04
-#define WCR_WDT		0x08
-#define WCR_SRS		0x10
-#define WCR_WDA		0x20
-#define SET_WCR_WT(x)	(x << 8)
+#define WCR_WDZST	BIT(0)
+#define WCR_WDBG	BIT(1)
+#define WCR_WDE		BIT(2)
+#define WCR_WDT		BIT(3)
+#define WCR_SRS		BIT(4)
+#define WCR_WDA		BIT(5)
+#define SET_WCR_WT(x)	((x) << 8)
 #define WCR_WT_MSK	SET_WCR_WT(0xFF)
+
+#define WRSR_SFTW	BIT(0)
+#define WRSR_TOUT	BIT(1)
diff --git a/net/bootp.c b/net/bootp.c
index 7ac0093945..55c80797e9 100644
--- a/net/bootp.c
+++ b/net/bootp.c
@@ -917,8 +917,8 @@ static void dhcp_process_options(uchar *popt, uchar *end)
 			if (dhcp_vendorex_proc(popt))
 				break;
 #endif
-			printf("*** Unhandled DHCP Option in OFFER/ACK:"
-			       " %d\n", *popt);
+			debug("*** Unhandled DHCP Option in OFFER/ACK: %d\n",
+			      *popt);
 			break;
 		}
 		popt += oplen + 2;	/* Process next option */
diff --git a/net/net.c b/net/net.c
index 57da9bda85..5b940c0013 100644
--- a/net/net.c
+++ b/net/net.c
@@ -603,6 +603,9 @@ restart:
 	 */
 	for (;;) {
 		WATCHDOG_RESET();
+#ifdef CONFIG_SHOW_ACTIVITY
+		show_activity(1);
+#endif
 		if (arp_timeout_check() > 0)
 			time_start = get_timer(0);
 
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
index ea71f9d234..aa5aeaef08 100644
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -12,6 +12,8 @@ CONFIG_DM9000_DEBUG
 CONFIG_DM9000_NO_SROM
 CONFIG_DM9000_USE_16BIT
 CONFIG_DW_WDT_CLOCK_KHZ
+CONFIG_ENV_CALLBACK_LIST_DEFAULT
+CONFIG_ENV_CALLBACK_LIST_STATIC
 CONFIG_ENV_FLAGS_LIST_STATIC
 CONFIG_ENV_IS_EMBEDDED
 CONFIG_ENV_SETTINGS_BUTTONS_AND_LEDS
@@ -254,6 +256,7 @@ CONFIG_SERIAL_SOFTWARE_FIFO
 CONFIG_SERVERIP
 CONFIG_SETUP_INITRD_TAG
 CONFIG_SET_DFU_ALT_BUF_LEN
+CONFIG_SHOW_ACTIVITY
 CONFIG_SH_ETHER_ALIGNE_SIZE
 CONFIG_SH_ETHER_CACHE_INVALIDATE
 CONFIG_SH_ETHER_CACHE_WRITEBACK
diff --git a/scripts/kconfig/conf.c b/scripts/kconfig/conf.c
index 376f796f67..47de6e296c 100644
--- a/scripts/kconfig/conf.c
+++ b/scripts/kconfig/conf.c
@@ -73,9 +73,14 @@ static void strip(char *str)
 /* Helper function to facilitate fgets() by Jean Sacren. */
 static void xfgets(char *str, int size, FILE *in)
 {
-	if (!fgets(str, size, in))
-		fprintf(stderr, "\nError in reading or end of file.\n");
-
+	if (!fgets(str, size, in)) {
+		if (feof(in))
+			fprintf(stderr, "\nEOF while reading console input\n");
+		else
+			fprintf(stderr, "\nError in reading console input: %s\n",
+				strerror(errno));
+		exit(1);
+	}
 	if (!tty_stdio)
 		printf("%s", str);
 }
